<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Attributed Variables in Prolog</title>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="description" content="Attributed Variables in Prolog">
    <meta name="keywords" content="Prolog,Constraints,Attributed variables">
    <meta name="author" content="Markus Triska">
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="prolog.css">
    <link rel="stylesheet" type="text/css" href="toc.css">
    <script>
      document.addEventListener("DOMContentLoaded", function() {
          var all_hide_on_start = document.getElementsByClassName('hide_on_start');
          for (var i = 0, m = all_hide_on_start.length; i < m; i++) {
              var element = all_hide_on_start[i];
              element.style.display = "none";
          }
      });
      function toggleOriginalContent(id) {
          var element = document.getElementById(id);
          if (element.style.display === "none") {
              element.style.display = "block";
          } else {
              element.style.display = "none";
          }
      }
    </script>
  </head>
  <body style="padding-left: 5%; padding-right: 5%; padding-bottom: 3cm">

    <br><br>
    <br><br>
    <center><h1>Prolog での属性付き変数</h1></center>
    <br><br>

    <b>属性付き変数</b> について最も重要なことは、
    Prolog アプリケーションプログラマーは通常
    それを<i>利用する必要はない</i>、ということです。
    この章は
    宣言的言語構造を実装/改善したい
    Prolog <b>ライブラリ作成者</b>を主な対象としています。

    <br><br>

    属性付き変数は宣言的構造を実装するための<b>低レベルメカニズム</b>です。
    ただし、単独で考えると、<a href="purity">純粋な</a>Prolog プログラムに
    適用したい<a href="reading#declarative"><i>宣言的読みやすさ</i></a>を妨げ、
    それに反する可能性があります。
    <br><br>
    このため、属性付き変数は、より<i>高レベル</i>メカニズムの
    <i>構成要素</i>としてのみ使用する必要があります。
    <br><br>
    もしあなたが Prolog ライブラリ作成者であるならば、
    このトピックに関心があるのは当然です。
    しかし、アプリケーション プログラマには、より宣言的なラッパーで
    同等の機能を提供する既存のライブラリを使用することをお勧めします。
    <br><br>
    Prolog実装者は、インターフェイス述語の一般性を評価するために、
    <a href="#minatotask"><b>Minato タスク</b></a>と
    <a href="#equivalencetask"><b>Equivalence タスク</b></a>に
    関心があるかもしれません。
    <br><br>

    <button onclick="toggleOriginalContent('原文_attributed_variables')">原文</button>
    <div id="原文_attributed_variables" class="hide_on_start">
    <center><h1>Attributed Variables in Prolog</h1></center>
    <br><br>

    The most important thing you need to know about <b>attributed
      variables</b> is that Prolog application&nbsp;programmers
    normally <i>need not use them</i>. This chapter is intended
    mainly for Prolog <b>library&nbsp;authors</b> who want to
    improve or implement more declarative language constructs.

    <br><br>

    Attributed variables are a <b>low-level mechanism</b> for
    implementing declarative constructs. However, when considered in
    isolation, they have the potential to prevent and run counter to
    the <a href="reading#declarative"><i>declarative</i>&nbsp;reading</a>
    we want to apply to <a href="purity">pure</a>
    Prolog&nbsp;programs.

    <br><br>

    For this reason, attributed variables should only be used as
    a <i>building&nbsp;block</i>
    for <i>higher-level</i>&nbsp;mechanisms.

    <br><br>

    If you are a Prolog library author, your interest in this topic
    may be warranted. To application programmers, my recommendation is
    to use existing libraries that provide equivalent functionality
    under more declarative&nbsp;wrappers.

    <br><br>

    Prolog implementors may be interested in
    the <a href="#minatotask"><b>Minato&nbsp;task</b></a> and
    in the <a href="#equivalencetask"><b>Equivalence&nbsp;task</b></a> to
    assess the generality of their interface predicates.
    </div>

    <center><h2>どのように始まったか</h2></center>

    初期の Prolog システム（<i>Prolog&nbsp;0</i>とも呼ばれる）で既に
    <i>制約</i><a href="concepts#builtin"><tt>dif/2</tt></a> が
    サポートされていました。

    <br><br>

    Prolog 実装者あるいは実践者はすぐに疑問を持ちました:
    <i>どんな<b>一般的メカニズム</b>で
      さらに便利で正しく効果的な制約を実装できるのか？</i>

    <br><br>

    この問題を解決する最初のメカニズムは、
    <a href="https://www.complang.tuwien.ac.at/ulrich/">Ulrich&nbsp;Neumerkel</a>
    による 1990 年の論文
    <a href="https://www.complang.tuwien.ac.at/ulrich/papers/PDF/meta90.pdf"><i>Extensible Unification by Metastructures</i></a>
    で提案されました。

    <br><br>

    論文からの重要な引用です:

    <blockquote class="quote">
      構文的単一化の拡張アプローチを考えると、次のことがわかります:
      高度に特殊化された実装では、ユーザは単一化アルゴリズムを制御できません
      (e.g.&nbsp;[Col87,JaLa87,vH89])。
      効率的に実装するには一般的すぎ
      既存の Prolog プログラムを再利用するには一般的すぎる[Ko84]、
      あるいは、手続き的言語でのみ拡張を定義できる[CLiST89]
      <br><br>

      我々のアプローチでは効率を保ったうえでの十分に抽象的なインターフェースに
      焦点を当て、
      制約変数の実際の表現を無視した
      <b>Prolog 上での制約の実装</b>の記述を可能にします。
      メタ構造は適用可能ですが、以下の領域に限定されません:
      <br><br>
      ...
    </blockquote>

    計画された利用ケースにおいて、
    副作用のないストリームベース I/O は論文で既に言及されています。
    これは現在
    <a href="http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/sicstus/pio.pl"><tt>library(pio)</tt></a>
    で利用可能です。

    <br><br>
    <button onclick="toggleOriginalContent('原文_it_started')">原文</button>
    <div id="原文_how_it_started" class="hide_on_start">
    <center><h2>How it started</h2></center>

    Already the first Prolog system, sometimes
    called <i>Prolog&nbsp;0</i>, supported the
    <i>constraint</i>&nbsp;<a href="concepts#builtin"><tt>dif/2</tt></a>.

    <br><br>

    To Prolog implementors and practitioners, the question soon
    became: <i>By which <b>general mechanism</b> can we we implement
      further constraints conveniently, correctly and efficiently</i>?

    <br><br>

    The first mechanism to solve this was proposed by
    <a href="https://www.complang.tuwien.ac.at/ulrich/">Ulrich&nbsp;Neumerkel</a>
    in his
    1990&nbsp;paper <a href="https://www.complang.tuwien.ac.at/ulrich/papers/PDF/meta90.pdf"><i>Extensible
    Unification by Metastructures</i></a>.

    <br><br>

    Here is a salient quote from the paper:

    <blockquote class="quote">
      When considering existing approaches of extensions to syntactic
unification, we observe: highly specialized implementations, where the
unification algorithm cannot be manipulated by the user
(e.g.&nbsp;[Col87,JaLa87,vH89]), approaches too general to be
implemented efficiently and too general to allow the reuse of existing
Prolog programs&nbsp;[Ko84], or extensions allowing definitions in a
procedural language&nbsp;[CLiST89] only.

      <br><br>

      Our approach focuses on a sufficient abstract yet efficient
interface, which permits to write <b>implementations of constraints in
Prolog</b>, neglecting the actual representation of the constrained
variables. Metastructures are applicable, but not restricted to the
      following areas:

      <br><br>
      ...
    </blockquote>

    Among the projected use cases, stream-based side effect free I/O
    is already mentioned in the paper. This is now available
    in <a href="http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/sicstus/pio.pl"><tt>library(pio)</tt></a>.
    </div>

    <center><h2>続いてなにが起きたか</h2></center>

    Ulrich&nbsp;Neumerkel の非常に親しい同僚であった
    Christian Holzbaur は、
    1990 年の博士論文「
    <i>Specification of Constraint Based Inference Mechanism through Extended Unification</i>」で
    メタ構造を使用し、CLP(Q) を実装しました。

    <br><br>

    この経験の後、メタ構造のいくつかの欠点に気づいた
    Holzbaur は
    <b>属性付き変数</b>（<b>attributed&nbsp;variables</b>）
    と呼ばれる非常に関連性の高い代替メカニズムを提案しました。

    <br><br>

    Holzbaur は後に比較する論文
    <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.3893&rep=rep1&type=pdf"><i>Metastructures vs. Attributed Variables in the Context of Extensible Unification</i></a>
    を公開しました。

    <br><br>

    Christian Holzbaur の提案は、
    この分野の先駆となった SICStus Prolog に採用されました。

    <br><br>

    SICStus ドキュメントの
    <a href="https://sicstus.sics.se/sicstus/docs/3.7.1/html/sicstus_17.html"><i>Attributed&nbsp;Variables</i></a>
    のセクションから引用すると:

    <blockquote class="quote">
      このパッケージは、属性付き変数を実装します。
      属性付き変数は、<i>変数とその属性の関連付け</i>を提供します。
      つまり、保存場所として使用できる名前付きプロパティを
      変数に関連付ける手段を提供します。
      また、そのような変数が他の項または互いに単一化するときに、
      デフォルトの単一化アルゴリズムを拡張することもできます。

      <br><br>

      この機能は、主に Prolog と制約ソルバーの間の
      クリーンなインターフェイスとして設計されましたが、
      他にもさまざまな用途があります。
      基本的なアイデアは Christian Holzbaur によるもので、
      最終的な設計に積極的に関与しました。背景資料については、
      [Holzbaur 90] を参照してください。
    </blockquote>

    開発の経緯についてより詳しく知りたい場合は
    関係者に直接問い合わせることをおすすめします。

    <br><br>

    同様のインターフェースは
    <a href="https://www.scryer.pl/">Scryer&nbsp;Prolog</a>、
    <a href="https://ciao-lang.org/">Ciao</a>
    といった他の Prolog システムにも実装されています。
    </div>

    <br><br>
    <button onclick="toggleOriginalContent('原文_it_started')">原文</button>
    <div id="原文_how_it_started" class="hide_on_start">
    <center><h2>How it continued</h2></center>

    Christian Holzbaur, who back then was a very close colleague of
    Ulrich&nbsp;Neumerkel, used metastructures in his
    1990&nbsp;dissertation, <i>Specification of Constraint Based
    Inference Mechanism through Extended Unification</i>, in which he
    implemented&nbsp;CLP(Q).


    <br><br>

    After this experience, and having observed some shortcomings of
    metastructures, Holzbaur proposed an alternative yet very strongly
    related mechanism called <b>attributed&nbsp;variables</b>.

    <br><br>

    Holzbaur later published a comparison paper, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.3893&rep=rep1&type=pdf"><i>Metastructures vs. Attributed Variables in the Context of Extensible Unification</i></a>.

    <br><br>

    The proposal by Christian Holzbaur was adopted in
    SICStus&nbsp;Prolog, one of the leading&nbsp;systems
    in the area of constraint&nbsp;programming.

    <br><br>

    To quote from the <a href="https://sicstus.sics.se/sicstus/docs/3.7.1/html/sicstus_17.html"><i>Attributed&nbsp;Variables</i></a> section in the
    SICStus documentation:

    <blockquote class="quote">
This package implements attributed variables. It provides a means of
<i>associating with variables arbitrary attributes</i>, i.e. named properties
that can be used as storage locations as well as to extend the default
unification algorithm when such variables are unified with other terms
or with each other.

<br><br>

This facility was primarily designed as a clean interface between
Prolog and constraint solvers, but has a number of other uses as well.
The basic idea is due to Christian Holzbaur and he was actively
involved in the final design. For background material, see the
dissertation&nbsp;[Holzbaur 90].
    </blockquote>


    If you are interested in more information about the origin of
    these developments, I recommend you ask the involved people
    in&nbsp;person.

    <br><br>

    The same interface is also implemented in other Prolog systems,
    such as in <a href="https://www.scryer.pl/">Scryer&nbsp;Prolog</a>
    and&nbsp;<a href="https://ciao-lang.org/">Ciao</a>.
    </div>

    <center><h2>現状、我々が手にしているもの</h2></center>

    属性付き変数の具体的機能は<i>Prolog システムによって異なります</i>。

    とはいえ、属性付き変数を提供するすべてのシステムにおいて、
    基本的に次の機能を利用できます:

    <ol>
      <li>変数への<i>情報の付与</i>が可能です</li>
      <li>変数が<i>単一化</i>されるときにこの情報を利用できます</li>
      <li>Prolog <a href="concepts#toplevel">トップレベル</a>
        の<i>回答表示</i> の際に、この情報を表示できます</li>
    </ol>

    続けて、特定の実装についてさらに機能の詳細を検討します。

    <br><br>
    <button onclick="toggleOriginalContent('原文_what_we_have_now')">原文</button>
    <div id="原文_what_we_have_now" class="hide_on_start">
    <center><h2>What we have now</h2></center>

    The concrete features of attributed variables <i>vary between
    Prolog&nbsp;systems</i>. However, in all systems that provide
    attributed variables, we have essentially the following features
    at our disposal:

    <ol>
      <li>We can <i>attach information</i> to variables.</li>
      <li>This information can be taken into account when a variable
        is being <i>unified</i>.</li>
      <li>This information can be <i>displayed in answers</i> on the
        Prolog <a href="concepts#toplevel">toplevel</a>.</li>
    </ol>

    In the following, we consider one specific implementation of these
    features in more detail.
    </div>

    <center><h2>Scryer Prolog における属性付き変数</h2></center>

    <br><br>
    <button onclick="toggleOriginalContent('原文_scryer_prolog')">原文</button>
    <div id="原文_scryer_prolog" class="hide_on_start">
    <center><h2>Attributed variables in Scryer Prolog</h2></center>
    </div>

    <center><h3>前置き</h3></center>

    属性付き変数の鍵となる概念を説明するにあたって、Scryer Prolog を考えます。
    これは、
    SICStus Prolog と同じインターフェースの属性付き変数を実装している
    フリーで利用可能な実装であるためです。

    <br><br>

    属性付き変数は Prolog アプリケーションでは
    通常<i>利用すべきでない</i>ことを再度強調しておきます。

    その代わりに、<b>制約論理プログラミング</b>機能、
    例えば <tt>dif/2</tt> や CLP(&#x2124;) が
    Scryer Prolog でも利用でき、
    典型的ユースケースではこれら高レベル述語を使用すべきです。

    <br><br>

    属性付き変数を使用する場合、上にアウトラインを示した機能に従って
    ３種類のインターフェース述語を知っておく必要があります:
    <ol>
      <li>属性を追加・更新・削除する述語</li>
      <li>属性が追加された変数の<i>単一化</i>について推論するための述語</li>
      <li>トップレベルで属性をなんらかの形式で<i>表示</i>させる述語</li>
    </ol>

    これらの述語を順に考えていきます。
    さらに情報を得たい場合、
    SICStus Prolog のマニュアル
    「<a href="https://sicstus.sics.se/sicstus/docs/latest4/html/sicstus.html/lib_002datts.html#lib_002datts">Attributed Variables</a>」
    を参照してください。
    他の Prolog システムで詳細は異なるものの、
    他のシステムでも述語の<i>種類</i>は同じです。

    <br><br>
    <button onclick="toggleOriginalContent('原文_preliminaries')">原文</button>
    <div id="原文_preliminaries" class="hide_on_start">
    <center><h3>Preliminaries</h3></center>

    To illustrate the key concepts of attributed variables, we
    consider Scryer&nbsp;Prolog because it is freely available, and it
    implements the same interface for attributed variables as
    SICStus&nbsp;Prolog.

    <br><br>

    I would like to stress again that attributed variables normally
    need&nbsp;not and also <i>should&nbsp;not be&nbsp;used</i> in
    typical Prolog&nbsp;applications. Instead, and also in
    Scryer&nbsp;Prolog, attributed variables are available to
    implement features from <b>Constraint Logic Programming</b> such
    as <tt>dif/2</tt> and CLP(&#x2124;), and you should use these
    higher-level predicates instead in typical use&nbsp;cases.

    <br><br>

    When working with attributed variables, you need to know
    3&nbsp;kinds of interface predicates, in accordance with the
    features outlined above:

    <ol>
      <li>Predicates for adding, changing and removing attributes.</li>
      <li>Predicates to reason about the <i>unification</i> of
        variables that have attributes attached.</li>
      <li>Predicates that let you <i>display</i> attributes on the toplevel in some form.</li>
    </ol>

    We now consider these kinds of predicates in turn. For more
    information, see especially
    <a href="https://sicstus.sics.se/sicstus/docs/latest4/html/sicstus.html/lib_002datts.html#lib_002datts">Attributed
    Variables</a> in the SICStus&nbsp;Prolog&nbsp;manual. Even though
    the details differ in other Prolog systems, the <i>kinds</i> of
    predicates are the same also in other systems.
    </div>

    <center><h3>属性の追加と更新</h3></center>

    属性付き変数は
    <i>変数</i>、<i>モジュール</i>、<i>値</i> の <i>関係</i> です。

    <br><br>

    SICStus や Scryer Prolog のインターフェースでは、
    <i>Name/Arity</i> ペアを使って
    <tt>attribute/1</tt> ディレクティブでモジュール内での属性を宣言します。

    <pre>
:- attribute Name<sub>1</sub>/Arity<sub>1</sub>, Name<sub>2</sub>/Arity<sub>2</sub>, ..., Name<sub><i>n</i></sub>/Arity<sub><i>n</i></sub>.
    </pre>

    <tt>library(atts)</tt> によってこのディレクティブは利用可能になります。

    <br><br>

    属性は以下で <i>追加</i>、<i>更新</i> が可能です:

    <br>
    <div id="put_atts" class="predicate">
      <tt><b>Module:put_atts(Var, AccessSpec)</b></tt>:
      <br>
      <tt>AccessSpec</tt> が <tt>+(Attribute)</tt> の形ならば、
      属性は指定された値に設定されます。
      <br>
      <tt>AccessSpec</tt> が <tt>-(Attribute)</tt> の形ならば、
      属性は指定された値から削除されます。
      <br>
      ラッパー <tt>+</tt> は省略可能です。
    </div>
    <br>

    これを試すために、
    属性 <tt>a/1</tt> を定義するサンプルモジュール
    <a href="attrmod.pl"><tt>attrmod.pl</tt></a>
    を作成します:

    <pre>
:- module(attrmod, []).

:- use_module(library(atts)).

:- attribute a/1.
    </pre>

    このファイルを consult すると、
    <a href="concepts#toplevel">トップレベル</a> で
    変数に属性を追加できます。例:

    <pre>
?- attrmod:put_atts(X, a(test)).
<b>   attrmod:put_atts(X,a(test)).</b>
    </pre>

    ここで応答として、Prolog トップレベルは
    単純に投入された内容を繰り返しています。
    そして、トップレベルは<i>答えが元のクエリと同等の宣言的に同等</i>という
    不変条件を保持しています。
    この例では、属性 <tt>a(test)</tt> はモジュール<tt>attrmod</tt>
    の変数<tt>X</tt>に関連付けられており、
    これが回答で述べられていることです。
    属性が関連づけられた変数を<i>属性付き変数</i>と呼びます。

    <br><br>

    重要なのは、<tt>put_attr/3</tt>を
    同じモジュールと同じ変数について<i>繰り返した</i>ならば、
    以前の関連付けは単純に<i>上書き</i>されることです。
    例えば:

    <pre>
?- attrmod:put_atts(X, a(hi)),
   attrmod:put_atts(X, a(ho)).
<b>   attrmod:put_atts(X,a(ho)).</b>
    </pre>

    とすると、これら２回の呼び出しで
    <b><tt>a(ho)</tt></b> は
    モジュール <tt>attrmod</tt> での <tt>X</tt>について残った
    唯一の属性になります。

    <br><br>

    <tt>put_atts/2</tt> は属性を <i>破壊的に変更する</i> とも言えます。
    このため、<tt>put_atts/2</tt>は、
    <tt>setarg/3</tt>のより宣言的でエラーが発生しにくい
    代替手段としても使用できます。

    <br><br>
    <tt>put_atts/2</tt> の効果はバックトラック時に<i>元に戻される</i>
    ことにも留意してください。例えば:

    <pre>
?- ( attrmod:put_atts(X, a(hello))
   ; true
   ).
<b>   attrmod:put_atts(X,a(hello))
;  true.</b>
    </pre>

    別解が通知されるとき、<tt>true</tt> 以外のゴールがないことにより
    <tt>X</tt> には<i>もはや属性はありません</i>。
    このため、変数に属性を割り当てることは、Prolog 組み込みの
    <a href="sorting#searching">探索</a>戦略とうまく調和しており、
    <i>単一化</i>に似ています。
    変更は<i>バックトラック可能</i>であると言うこともできます。

    <br><br>
    <button onclick="toggleOriginalContent('原文_adding_and_changing')">原文</button>
    <div id="原文_adding_and_changing" class="hide_on_start">
    <center><h3>Adding and changing attributes</h3></center>

    An attributed variable is a <i>relation</i> between
    a&nbsp;<i>variable</i>, a&nbsp;<i>module</i> and
    a&nbsp;<i>value</i>.

    <br><br>

    With the interface of SICStus and Scryer Prolog, we declare
    attributes in a module with the <tt>attribute/1</tt> directive, using <i>Name/Arity</i> pairs:

    <pre>
:- attribute Name<sub>1</sub>/Arity<sub>1</sub>, Name<sub>2</sub>/Arity<sub>2</sub>, ..., Name<sub><i>n</i></sub>/Arity<sub><i>n</i></sub>.
    </pre>

    This directive is made available via <tt>library(atts)</tt>.

    <br><br>

    An attribute can be <i>added</i> and <i>changed</i> via:

    <br>
    <div id="put_atts" class="predicate">
      <tt><b>Module:put_atts(Var, AccessSpec)</b></tt>:
      <br>
      If <tt>AccessSpec</tt> is of the form <tt>+(Attribute)</tt>,
      then the corresponding attribute is set to the specified value.
      If <tt>AccessSpec</tt> is of the form <tt>-(Attribute)</tt>,
      then the attribute is removed. For convenience, the
      wrapper&nbsp;<tt>+</tt> can be omitted.
    </div>

    <br>

    To try this, let us define a sample module,
    say <a href="attrmod.pl"><tt>attrmod.pl</tt></a>, where we declare
    the attribute <tt>a/1</tt>:

    <pre>
:- module(attrmod, []).

:- use_module(library(atts)).

:- attribute a/1.
    </pre>

    After consulting the file, we can use the
    <a href="concepts#toplevel">toplevel</a> to attach attributes to
    variables. For example:

    <pre>
?- attrmod:put_atts(X, a(test)).
<b>   attrmod:put_atts(X,a(test)).</b>
    </pre>


    We see that in response, the Prolog toplevel simply repeats what
    we said. Thus, the toplevel retains the important invariant
    that <i>the answer is declaratively equivalent to the original
    query</i>. In this concrete case, all there is to say is: The
    attribute <tt>a(test)</tt> is associated with the
    variable&nbsp;<tt>X</tt> in module&nbsp;<tt>attrmod</tt>, and that's
    exactly what this answer states. We call a variable that has an
    attribute attached an <i>attributed&nbsp;variable</i>.

    <br><br>

    Importantly, when you use <tt>put_attr/3</tt> <i>repeatedly</i>
    with the same variable and module, then any previously attached
    value is simply <i>overwritten</i>. For example:

    <pre>
?- attrmod:put_atts(X, a(hi)),
   attrmod:put_atts(X, a(ho)).
<b>   attrmod:put_atts(X,a(ho)).</b>
    </pre>

    Thus, after these two calls, <b><tt>a(ho)</tt></b> is the single
    remaining attributed that is attached to <tt>X</tt> in
    module&nbsp;<tt>attrmod</tt>.

    <br><br>

    We say that <tt>put_atts/2</tt> <i>destructively modifies</i> an
    attribute. For this reason, you can use <tt>put_atts/2</tt> also
    as a somewhat more declarative and less error-prone alternative
    to&nbsp;<tt>setarg/3</tt>.

    <br><br>

    Note also that the effect of <tt>put_atts/2</tt> is <i>undone</i>
    on backtracking. For example:

    <pre>
?- ( attrmod:put_atts(X, a(hello))
   ; true
   ).
<b>   attrmod:put_atts(X,a(hello))
;  true.</b>
    </pre>

    When the alternative is reported, we see from the absence of any
    goals besides&nbsp;<tt>true</tt> that <i>no more attribute</i> is
    attached to&nbsp;<tt>X</tt>. For this reason, assigning attributes
    to variables blends well with Prolog's
    built-in <a href="sorting#searching">search</a>&nbsp;strategy, and
    is similar to <i>unification</i> in that respect. We say that the
    modification is <i>backtrackable</i>.
    </div>

    <center><h3>属性付き変数の単一化</h3></center>

    変数と<i>属性付き</i>変数との違いは、
    <i>単一化</i>のときになにが起きるかです。

    <br><br>

    属性付き変数は単一化の際に
    <i>拡張可能な</i>述語が<i>自動的に呼び出される</i>というのが特別です。
    SICStus と Scryer では、属性が付与されている<i>モジュール</i>の
    <tt>verify_attributes/3</tt>が呼び出されます。
    Prolog プログラマはこの述語の<i>定義</i>を変更できます。
    属性が付与された変数を単一化する際に Prolog エンジンは自動的に
    その定義を呼び出します。

    <br><br>
    例えば、モジュール <a href="attrmod.pl"><tt>attrmod</tt></a>
    で <tt>verify_attributes/3</tt> の非常に基本的なバージョンを定義します:

    <pre>
verify_attributes(X, Y, _) :- throw(cannot_unify(X,Y)).
    </pre>

    この定義では、単純に<i>例外</i>をスローするだけなので、このような結果を得ます:

    <pre>
?- attrmod:put_atts(X, a(1)),
   attrmod:put_atts(Y, a(2)),
   <b>X = Y</b>.
   <b>throw(cannot_unify(_397,_399)).</b>
    </pre>

    <br>
    <div id="verify_attributes" class="predicate">
      <tt><b>M:verify_attributes(-Var, +Value, -Goals)</b></tt>:
      <br><br>
      <i>モジュール</i>内に属性を持つ可能性のある変数<i>Var</i>が
      <i>Value</i>にバインドされようとしているときにこの変数が呼び出されます
      （ない場合もあります）。
      単一化は <tt>verify_attributes/3</tt> 呼び出しに後で再開されます。
      <i>Value</i> は非変数、あるいは他の属性付き変数です。
      <i>Var</i> は<i>モジュール</i>内に属性を持たない可能性があります。

      <br><br>

      <tt>verify_attributes/3</tt> は<i>Var</i>が<i>Value</i>に
      バインドされる<i>前に</i>呼び出されます。
      バインドが失敗した場合、単一化失敗です。
      別解を得るために単一化がバックトラックした場合は、
      非決定的に成功する場合があります。
      <i>Goals</i>には、<i>Var</i>が<i>Value</i>に
      バインドされた後に呼び出されるゴールのリストを返すことが期待されます。
      最後に、<i>Goals</i>呼び出し後に、
      <i>Var</i>でブロックされているなんらかのゴールが呼び出されます。

      <br><br>

      <tt>verify_attributes/3</tt> は任意の Prolog ゴールを呼び出します。
      しかし、<i>Var</i> はそれによってバインドされるべきではありません。
      <i>Var</i> のバインドは未定義動作の原因となります。

      もし<i>Value</i>が非変数であるならば、
      <tt>verify_attributes/3</tt>は<i>Var</i>の属性を検査し、それが
      Value との互換性があるかチェックし、そうでなければ失敗します。
      もし<i>Value</i>が他の属性付き変数であるならば、
      <tt>verify_attributes/3</tt> は
      <i>Var</i> を<i>Value</i>にバインドする準備として、
      <i>Var</i>の属性を<i>Value</i>の
      属性としてコピーするか、マージします。
      どちらにしても、<tt>verify_attributes/3</tt> は
      バインドされていない<i>List</i>の元で
      <tt>get_atts(Var, List)</tt>を呼び出すことで
      <i>Var</i>の現在の属性を判定します。

      <br><br>

      一つの単一化で複数の属性付き変数をバインドする場合、
      そのようなバインドすべてを解除したうえで
      各変数について次の動作を行います:

      <ol>
        <li>関連モジュール<tt>M</tt> それぞれについて、
          <tt>M:verify_attributes/3</tt> を呼び出し、
          その結果である <i>Goals</i> を取得します</li>
        <li>変数のバインドをやり直します</li>
        <li><i>Goals</i> を呼び出します</li>
        <li>ブロックされているゴールを呼び出します</li>
      </ol>

    </div>

    <br><br>

    最初に、ドキュメントに記載されている内容を試してみましょう:
    例えば、単一化を<i>fail</i>させます。

    <pre>
verify_attributes(_, _, _) :- <b>false</b>.
    </pre>

    クエリと回答の例:

    <pre>
?- attrmod:put_atts(X, a(n(1))),
   attrmod:put_atts(Y, a(n(2))),
   <b>X = Y</b>.
   <b>false.</b>
    </pre>

    OK、これは宣伝どおりに動作します。この例およびこれに続く例で、
    <tt>n(N)</tt>の形の<a href="data#term">複合項</a>で
    整数<tt>N</tt>を表現します。
    整数を直接使用する<i>ことも</i>できます。
    しかし、これには<a href="data#clean">デフォルトの</a>表現で
    終わってしまうリスクがあり、
    以下のコードにおいて記号的に属性と変数との区別を妨げます。

    <br><br>

    次に、単一化について関連する属性を<i>変更</i>します。
    単一化に<i>２つ</i>（あるいはもっと）変数を含む場合、
    それらの変数に単一化がどう作用するか明確にする必要があります。

    <br><br>

    上記の例を拡張しましょう:
    上記の例では、属性<tt>a/1</tt>を使って
    Prolog 項 <tt>n(1)</tt> と <tt>n(2)</tt> を
    変数 <tt>X</tt> と <tt>Y</tt> を結びつけました。
    インターフェースの経験を積むために、
    ２つの変数を単一化して、
    属性 <tt>a(n(A))</tt> と <tt>a(n(B))</tt>
    （ここで <tt>A</tt> と <tt>B</tt> は整数）
    から新しい属性 <tt>a(n(C))</tt>
    （ここで <tt>C</tt> は <tt>A</tt> と <tt>B</tt> の<i>合計</i>）
    を得たいと思います。

    <br><br>

    これを実現するには、
    変数の<i>既存の</i>属性を推論する方法が必要です。
    述語 <tt>get_atts/2</tt> をこの目的で利用できます:

    <br>
    <div id="get_atts" class="predicate">
      <tt><b>get_atts(Var, AccessSpec)</b></tt>:
      <br>
      <tt>AccessSpec</tt> が <tt>+(Attribute)</tt> の形ならば、
      関連する属性が存在する必要があり、
      かつ、<tt>Attribute</tt>と単一化されます。
      <br>
      ラッパー<tt>+</tt> は省略可能です。
    </div>
    <br>

    したがって、次の手順を実装します:

    <ol>
      <li>モジュール<tt>attrmod</tt>から属性を持つ２つの変数を
        単一化することで、<tt>a/</tt> 属性を<i>取得</i>します。
      </li>

      <li>属性に含まれる整数の<i>合計</i>を
        <a href="clpfd">整数演算</a>
        を用いて計算します。</li>
      <li>新しい属性に合計を与えます。
      </li>
    </ol>

    Prolog ではこのようになります:

    <pre>
verify_attributes(Var, Value, []) :-
        get_atts(Var, a(n(A))),
        get_atts(Value, a(n(B))),    % step (1)
        C #= A + B,                  % step (2)
        put_atts(Value, a(n(C))).    % step (3)
    </pre>

    それでは試してみましょう:

    <pre>
?- attrmod:put_atts(X, a(n(1))),
   attrmod:put_atts(Y, a(n(2))),
   X = Y.
<b>   X = Y, attrmod:put_atts(Y,a(n(3))).</b>
    </pre>

    確かに動作します:
    単一化後、<tt>a(n(3))</tt> は単一の変数に関連付けられ、
    <tt>X</tt> と <tt>Y</tt> は<i>同様に</i> 1+2 の結果の 3 です。

    <br><br>

    次の例では <i>uninstantiation&nbsp;error</i> が発生します。
    なぜなら（<tt>verify_attributes/3</tt>の定義に用いている）
    <tt>get_atts/2</tt> の最初の引数は<i>変数</i>でなければならない
    のにアトム<tt>b</tt>を使っているためです:

    <pre>
?- attrmod:put_atts(X, a(n(1))),
   <b>X = b</b>.
   <b>error(uninstantiation_error(b),get_atts/2).</b>
    </pre>

    実際、上の <tt>verify_attributes/3</tt> の定義では
    非常に特殊な種類の単一化のみ<i>成功</i>します。
    特に、<i>基底</i>値に関するすべての単一化は uninstantiation error
    を発生します。
    ただし、実際の制約システムでは
    基底項は具体的な<i>解</i>の典型的な表現であるため、
    基底項に特別な関心があります。

    <br><br>

    そこで、上記（モジュール<tt>attrmod</tt>での）
    <tt>verify_attributes/3</tt> の定義を一般化して
    インターフェース全体の重要な機能である
    <i>選択的な単一化の拒否</i>を記述しましょう。
    例えば、具体的ケースにおいて具体的な<b>整数</b>との単一化を許すのは
    その整数が、関係する変数の属性に格納されている関連する整数値と
    一致する場合とする場合とします。

    <br><br>

    そのためには
    2つの項<tt>X</tt>と<tt>Y</tt>が単一化される2つの異なるケースを
    <i>区別</i>する必要があります。
    <tt>X</tt>の観点から考えてみます。
    つまり、
    <tt>verify_attributes/3</tt> が <tt>X</tt> を最初の引数として
    呼び出されるものとします。
    （もちろん、もう一方のケースは完全に対象的です。それでも議論には
    両者を区別して扱う必要があります。）

    そして、<tt>Y</tt>が<i>整数</i><i>k</i>で
    <tt>X</tt> の属性にストアされた整数とマッチしないならば
    単一化を拒否（つまり失敗）させる必要があります。

    <tt>Y</tt>が属性付き<i>変数</i>の場合、
    以前のように動作する必要があります:
    関連する変数の２つの属性にストアされた
    ２つの整数の<i>合計</i>を計算し、
    単一化された変数にその合計を結びつけます。

    <br><br>

    Prolog では、組み込み述語 <tt>integer/1</tt> を用いて
    この区別を表現します:

    <pre>
verify_attributes(Var, Value, []) :-
        get_atts(Var, a(n(A))),
        (   <b>integer(Value)</b> ->
            Value =:= A
        ;   get_atts(Value, a(n(B)))
            C #= A + B,
            put_atts(Var, -a(n(_))),
            put_atts(Value, a(n(C)))
        ).
    </pre>

    以下にいくつかのサンプルクエリとその結果を示します:

    <pre>
?- attrmod:put_atts(X, a(n(1))), X = 1.
   <b>X = 1.</b>

?- attrmod:put_atts(X, a(n(1))), X = 3.
   <b>false.</b>

?- attrmod:put_atts(X, a(n(1))),
   attrmod:put_atts(Y, a(n(2))),
   X = Y,
   X = 3.
   <b>X = Y, Y = 3.</b>
    </pre>

    このように、すべてが意図したとおりに機能しているようです。
    私たちは、確かにかなり特異なセマンティクスを持ちますが、
    私たちが概説したことを実装する、
    単純な<i>制約ソルバー</i>を作成できました。
    ただし、このソルバーには非常に重大な宣言的欠陥があります。
    上記の結合で 目標<tt>X = Y</tt>を削除するとそれが明らかになります。

    <pre>
?- attrmod:put_atts(X, a(n(1))),
   attrmod:put_atts(Y, a(n(2))),
   X = 3.
   <b>false.</b>
    </pre>

    この例では、クエリの（制約を<i>削除</i>することによる）<i>一般化</i>
    が<i>より具体的</i>プログラム（<tt>false</tt>と同じ）を生成しています。
    これは、論理プログラムに期待される基本的なプロパティに違反しており、
    たとえば<a href="debugging">宣言的デバッグ</a>を妨げます。

    <br><br>

    このことから得られる重要なポイントは、
    <i>属性付き変数のインターフェイスだけでは、
      結果として得られる制約ソルバーの保証がまったく提供されない</i>
    ということです。
    プログラマーは、結果として得られるプログラムで
    望ましいプロパティが保持されるように
    システムを実装する必要があります。この点については後で説明します。

    <br><br>

    今はとりあえずこのセクションを、より興味深く、より現実的な例で
    締めくくります:
    ここでは、<i>有限ドメイン</i>上の単純な制約ソルバーを実装します。
    ここで、関係する各変数の属性は、変数の許容<i>ドメイン</i>を表す
    要素の<i>順序付きリスト</i>です。

    <br><br>

    このような制約ソルバーに適した統一フックは次のようにものです:

    <pre>
verify_attributes(Var, Other, []) :-
        (   get_atts(Var, domain(Dom1)) ->
            (   var(Other),
                get_atts(Other, domain(Dom2)) ->
                ord_intersection(Dom1, Dom2, Dom),
                dif(Dom, []),
                (   Dom = [Value] ->
                    Other = Value
                ;   put_atts(Other, domain(Dom))
                )
            ;   ord_memberchk(Other, Dom1)
            )
        ;   true
        ).
    </pre>

    非公式には、次のように読むことができます:

    <ol>
      <li><tt>Var</tt> が関連するドメイン<tt>Dom1</tt>を持ち、
        <tt>Other</tt> が関連するドメイン<tt>Dom2</tt>を持つ場合、
        共通部分(intersection)
        <tt>Dom</tt> = <tt>Dom1</tt> &cap; <tt>Dom2</tt>
        を構築します。この順序付きリストは
        単一化された<i>両方の</i>変数に許容されるすべての要素を含みます。
      </li>

      <li><tt>Dom</tt>が空<a href="data#list">リスト</a> <tt>[]</tt>
        と<i>異なる</i>(<tt>dif/2</tt>)ときにのみ続行します。
        結果の単一化変数に許容されるドメイン要素が少なくとも一つ残ります。
      </li>

      <li><tt>Dom</tt>が残り要素一つだけ持っているとき、
        その要素は単一化変数と<i>等しい</i>必要があります
        （他の選択肢がないため）。
      </li>

      <li>その他の場合、共通部分<tt>Dom</tt>を単一化変数の
        <i>属性</i>として割り当てます。</li>

      <li><tt>Other</tt>に関連するドメインがない場合、
        <tt>Other</tt>がドメイン<tt>Dom1</tt>のメンバーであるときのみ
        単一化を許容します。
      </li>
    </ol>

    付け加えて、変数とそのドメインを関連付ける次の定義を使用します:

    <pre>
domain(X, List) :-
        list_to_ord_set(List, Dom),
        <a href="#put_atts">put_atts</a>(X, domain(Dom)).
    </pre>

    これらの定義によって、クエリを実行できます:

    <pre>
?- domain(X, "abc"),
   domain(Y, "cde"),
   X = Y.
    </pre>

    応答として、具体的な解が得られます:

    <pre>
   <b>X = Y, Y = c.</b>
    </pre>

    単一化についてこれが動作するのは、フックが呼び出されることで
    ２つのドメインの共通部分が構築されて、
    結果の変数がその要素と単一化されるためです。
    <tt>X</tt>と<tt>Y</tt>は完全に区別できなくなったことに注意してください。
    単一化はこれらを完全に<i>単一化</i>します。

    <br><br>

    <b>練習</b>（難しい）:
    次の特性は、制約ソルバーにとって非常に望ましいものです。
    この場合に当てはまることを証明するか、反例を示してください。
    <br>
    <i><tt>domain/2</tt>および<tt>(=)/2</tt>のゴールのみで構成される
      すべての Prolog クエリ <tt>Q</tt>について、
      ゴールの 1 つ を<i>削除</i>すると、
      結果のクエリ<tt>Q'</tt>は、
      <tt>Q</tt>のソリューションの集合が
      <tt>Q'</tt>のソリューションの集合のサブセットである
      という意味において、少なくとも<tt>Q</tt>と同じくらい一般化される。
    </i>

    <br><br>
    <button onclick="toggleOriginalContent('原文_unification')">原文</button>
    <div id="原文_unification" class="hide_on_start">
    <center><h3>Unification of attributed variables</h3></center>

    The key distinction between variables and <i>attributed</i>
    variables is what happens at the time of&nbsp;<i>unification</i>.

    <br><br>

    Attributed variables are special in that an <i>extensible</i>
    predicate is <i>automatically&nbsp;invoked</i> when they are
    unified. In SICStus and Scryer, the particular predicate that is invoked
    is <tt>verify_attributes/3</tt> residing in the <i>module</i> where
    the attribute is attached. You, the Prolog&nbsp;programmer, can
    provide a custom <i>definition</i> of this predicate, and it will
    be automatically invoked by the Prolog&nbsp;engine when a variable
    that has attributes attached is being unified.

    <br><br>

    For example, let us define a very rudimentary version
    of <tt>verify_attributes/3</tt> in our
    module&nbsp;<a href="attrmod.pl"><tt>attrmod</tt></a>:

    <pre>
verify_attributes(X, Y, _) :- throw(cannot_unify(X,Y)).
    </pre>

    With this definition, which simply throws an <i>exception</i> when
    it is invoked, we get for example:


    <pre>
?- attrmod:put_atts(X, a(1)),
   attrmod:put_atts(Y, a(2)),
   <b>X = Y</b>.
   <b>throw(cannot_unify(_397,_399)).</b>
    </pre>

    <br>
    <div id="verify_attributes" class="predicate">
      <tt><b>M:verify_attributes(-Var, +Value, -Goals)</b></tt>:
      <br><br>
      This predicate is called whenever a variable <i>Var</i> that might have
      attributes in <i>Module</i> is about to be bound to <i>Value</i> (it might
      have none). The unification resumes after the call to
      <tt>verify_attributes/3</tt>. <i>Value</i> is a nonvariable, or another
      attributed variable. <i>Var</i> might have no attributes present in
      <i>Module</i>.

      <br><br>

      <tt>verify_attributes/3</tt> is called <i>before</i> <i>Var</i> has
      actually been bound to <i>Value</i>. If it fails, the unification is
      deemed to have failed. It may succeed nondeterminately, in which
      case the unification might backtrack to give another answer. It
      is expected to return, in <i>Goals</i>, a list of goals to be called
      after <i>Var</i> has been bound to <i>Value</i>. Finally, after calling <i>Goals</i>,
      any goals blocked on <i>Var</i> are called.

      <br><br>

      <tt>verify_attributes/3</tt> may invoke arbitrary Prolog goals,
      but <i>Var</i> should not be bound by it. Binding <i>Var</i> will result in
      undefined behavior.

      If <i>Value</i> is a nonvariable, <tt>verify_attributes/3</tt>
      will typically inspect the attributes of <i>Var</i> and check that they
      are compatible with Value and fail otherwise. If <i>Value</i> is
      another attributed variable, <tt>verify_attributes/3</tt> will typically
      copy the attributes of <i>Var</i> over to <i>Value</i>, or merge them with
      <i>Value</i>’s, in preparation for <i>Var</i> to be bound
      to <i>Value</i>. In either case, <tt>verify_attributes/3</tt> may
      determine <i>Var</i>’s current attributes by calling <tt>get_atts(Var, List)</tt>
      with an unbound <i>List</i>.

      <br><br>

      In the case when a single unification binds multiple attributed
      variables, first all such bindings are undone, then the
      following actions are carried out for each relevant variable:

      <ol>
        <li>For each relevant module <tt>M</tt>, <tt>M:verify_attributes/3</tt> is called, collecting a list of returned <i>Goals</i>.</li>
        <li>The variable binding is redone.</li>
        <li>Any <i>Goals</i> are called.</li>
        <li>Any blocked goals are called. </li>
      </ol>

    </div>

    <br><br>

    First, let us try out what the documentation states: For example,
    let us make the unification&nbsp;<i>fail</i>.

    <pre>
verify_attributes(_, _, _) :- <b>false</b>.
    </pre>

    Example query and answer:

    <pre>
?- attrmod:put_atts(X, a(n(1))),
   attrmod:put_atts(Y, a(n(2))),
   <b>X = Y</b>.
   <b>false.</b>
    </pre>

    OK, this works as advertised. In this example and the following,
    we use
    <a href="data#term">compound&nbsp;terms</a> of the
    form&nbsp;<tt>n(N)</tt> to represent the integer&nbsp;<tt>N</tt>.
    We <i>could</i> also use the integers directly instead. However,
    this would risk ending up with a <a href="data#clean">defaulty</a>
    representation, and also prevent us from symbolically
    distinguishing attributes from variables in the code
    below.

    <br><br>

    Second, let us <i>modify</i> the
    involved attributes upon unification. If a unification
    involves <i>two</i> (or more) variables, we must
    state how such a unification affects the involved variables.

    <br><br>

    Let us extend the example from above: In the above case, we have
    associated the Prolog terms <tt>n(1)</tt> and&nbsp;<tt>n(2)</tt>
    with the variables <tt>X</tt> and&nbsp;<tt>Y</tt>, using the
    attribute&nbsp;<tt>a/1</tt>. To gather experience with the
    interface, let us say that upon unification of two variables with
    respective attributes <tt>a(n(A))</tt> and <tt>a(n(B))</tt>,
    where <tt>A</tt> and <tt>B</tt> are integers, we want to attach
    the new attribute <tt>a(n(C))</tt> to the resulting (single)
    variable, where <tt>C</tt> is the <i>sum</i> of <tt>A</tt>
    and&nbsp;<tt>B</tt>.

    <br><br>

    To accomplish this, we need a way to reason about <i>existing</i>
    attributes of variable. The predicate <tt>get_atts/2</tt> is
    available for this purpose:

    <br>
    <div id="get_atts" class="predicate">
      <tt><b>get_atts(Var, AccessSpec)</b></tt>:
      <br>
      If <tt>AccessSpec</tt> is of the form <tt>+(Attribute)</tt>,
      then the corresponding attribute must be present and is unified
      with <tt>Attribute</tt>. For convenience, the
      wrapper&nbsp;<tt>+</tt> can be omitted.
    </div>
    <br>

    Thus, we shall now implement the following steps:

    <ol>
      <li>Upon unification of two variables with attributes from
        module&nbsp;<tt>attrmod</tt>, <i>fetch</i>
        their <tt>a/1</tt>&nbsp;attributes.
      </li>

      <li>Compute the <i>sum</i> of the integers in the attributes,
        using <a href="clpfd">integer arithmetic.</a></li>

      <li>Attach the sum as the new attribute.
      </li>
    </ol>

    In Prolog, this becomes:

    <pre>
verify_attributes(Var, Value, []) :-
        get_atts(Var, a(n(A))),
        get_atts(Value, a(n(B))),    % step (1)
        C #= A + B,                  % step (2)
        put_atts(Value, a(n(C))).    % step (3)
    </pre>

    Now, let us try it out:

    <pre>
?- attrmod:put_atts(X, a(n(1))),
   attrmod:put_atts(Y, a(n(2))),
   X = Y.
<b>   X = Y, attrmod:put_atts(Y,a(n(3))).</b>
    </pre>

    And indeed this works: After the unification, <tt>a(n(3))</tt> is
    associated with the resulting single variable, which is <tt>X</tt>
    or, <i>equivalently</i>,&nbsp;<tt>Y</tt>, and 3 is the result
    of&nbsp;1+2.

    <br><br>

    The following yields an <i>uninstantiation&nbsp;error</i>, because
    because <tt>get_atts/2</tt>&mdash;which is used in our definition
    of <tt>verify_attributes/3</tt>)&mdash;requires its first argument
    to be a <i>variable</i>, whereas we use the atom&nbsp;<tt>b</tt>:

    <pre>
?- attrmod:put_atts(X, a(n(1))),
   <b>X = b</b>.
   <b>error(uninstantiation_error(b),get_atts/2).</b>
    </pre>

    In fact, with the above definition of <tt>verify_attributes/3</tt>,
    only very specific kinds of unifications will <i>succeed</i>. In
    particular, every unification with a <i>ground</i> value will
    yield an uninstantiation&nbsp;error. However, in actual
    constraint&nbsp;systems, we are very interested in ground terms,
    because they typically represent concrete <i>solutions</i>.

    <br><br>

    Let us therefore <i>generalize</i> the above definition
    of <tt>verify_attributes/3</tt> (in module&nbsp;<tt>attrmod</tt>)
    in such a way that it still illustrates a key feature of the whole
    interface, namely the ability to <i>selectively veto
    unifications</i>. For example, in our concrete case, let us allow
    unifications with a concrete <b>integer</b> <i>iff</i> that
    integer matches the associated integer value that is stored in the
    involved variable's attribute.

    <br><br>

    We hence must <i>distinguish</i> two different cases when two
    terms&nbsp;<tt>X</tt> and <tt>Y</tt> are unified. Let us consider
    it from the perspective of <tt>X</tt>, i.e., let us suppose
    that <tt>verify_attributes/3</tt> is invoked with <tt>X</tt> as
    the first argument. (Of course, the other case is completely
    symmetric, but we need to draw this distinction to discuss the
    cases.) Then, <i>either</i> <tt>Y</tt> is
    an <i>integer</i>&nbsp;<i>k</i>. In that case, we must <i>veto</i>
    the unification (i.e., fail) if <i>k</i> does not match the
    integer that is stored in the attribute
    of&nbsp;<tt>X</tt>. <i>Or</i> <tt>Y</tt> is an
    attributed <i>variable</i>. In that case, we proceed exactly as
    previously: We compute the <i>sum</i> of the two integers that are
    stored in the attributes of the involved variables, and associate
    that sum with the unified variable.

    <br><br>

    In Prolog, we can express this distinction with the built-in
    predicate <tt>integer/1</tt>:

    <pre>
verify_attributes(Var, Value, []) :-
        get_atts(Var, a(n(A))),
        (   <b>integer(Value)</b> ->
            Value =:= A
        ;   get_atts(Value, a(n(B)))
            C #= A + B,
            put_atts(Var, -a(n(_))),
            put_atts(Value, a(n(C)))
        ).
    </pre>

    Here are a few sample queries and their results:

    <pre>
?- attrmod:put_atts(X, a(n(1))), X = 1.
   <b>X = 1.</b>

?- attrmod:put_atts(X, a(n(1))), X = 3.
   <b>false.</b>

?- attrmod:put_atts(X, a(n(1))),
   attrmod:put_atts(Y, a(n(2))),
   X = Y,
   X = 3.
   <b>X = Y, Y = 3.</b>
    </pre>

    Thus, everything seems to work as intended. We have successfully
    created a simplistic <i>constraint&nbsp;solver</i>, which
    admittedly has quite peculiar semantics but implements what we
    have outlined. However, this concrete solver has a very severe
    declarative&nbsp;flaw, which becomes apparent if you eliminate the
    goal <tt>X&nbsp;=&nbsp;Y</tt> in the above conjunction:

    <pre>
?- attrmod:put_atts(X, a(n(1))),
   attrmod:put_atts(Y, a(n(2))),
   X = 3.
   <b>false.</b>
    </pre>

    In this case, <i>generalizing</i> a query (by <i>removing</i> a
    constraint) has created a
    <i>more&nbsp;specific</i> program (which is now equivalent
    to <tt>false</tt>). This violates elementary properties we expect
    from logic&nbsp;programs and
    prevents for example <a href="debugging">declarative&nbsp;debugging</a>.

    <br><br>

    The key takeaway from this is that <i>the interface for attributed
    variables does not by itself provide any guarantees of the
    resulting constraint&nbsp;solver</i>. You, the programmer, must
    implement your system in such a way that desirable properties are
    preserved in resulting programs. We return to this point below.

    <br><br>

    For now, let us conclude this section with a more interesting and
    also more realistic example: We now implement a simplistic
    constraint solver over <i>finite&nbsp;domains</i>, where the
    attribute of each involved variable is an <i>ordered&nbsp;list</i>
    of elements, representing the admissible <i>domain</i> of the
    variable.

    <br><br>

    A suitable unification hook for such a constraint solver could
    look like this:

    <pre>
verify_attributes(Var, Other, []) :-
        (   get_atts(Var, domain(Dom1)) ->
            (   var(Other),
                get_atts(Other, domain(Dom2)) ->
                ord_intersection(Dom1, Dom2, Dom),
                dif(Dom, []),
                (   Dom = [Value] ->
                    Other = Value
                ;   put_atts(Other, domain(Dom))
                )
            ;   ord_memberchk(Other, Dom1)
            )
        ;   true
        ).
    </pre>

    Informally, we can read this as:

    <ol>
      <li>If <tt>Var</tt> has an associated domain&nbsp;<tt>Dom1</tt>,
        and <tt>Other</tt> is a variable that has an associated
        domain <tt>Dom2</tt>, then we build
        the <i>intersection</i> <tt>Dom</tt> =
        <tt>Dom1</tt> &cap; <tt>Dom2</tt>. This ordered list contains
        all elements that are admissible for <i>both</i> variables
        that have been unified.
      </li>

      <li>We only proceed if <tt>Dom</tt> is <i>different</i>
        (<tt>dif/2</tt>) from the
        empty <a href="data#list">list</a>&nbsp;<tt>[]</tt>, and
        hence there is at least one remaining domain element
        that is admissible for the resulting unified variable.
      </li>

      <li>If <tt>Dom</tt> has only a single remaining element, then
        that element must be <i>equal&nbsp;to</i> the unified variable
        (because there is no other choice).
      </li>

      <li>Otherwise, assign the intersection <tt>Dom</tt> as
        an <i>attribute</i> to the unified variable.</li>

      <li>If <tt>Other</tt> has no associated domain, then the
        unification is only admissible if <tt>Other</tt> is
        a <i>member</i> of the domain&nbsp;<tt>Dom1.</tt>
      </li>
    </ol>

    In addition, let us use the following definition to associate a
    variable with its domain:

    <pre>
domain(X, List) :-
        list_to_ord_set(List, Dom),
        <a href="#put_atts">put_atts</a>(X, domain(Dom)).
    </pre>

    With these definitions in place, we can query:

    <pre>
?- domain(X, "abc"),
   domain(Y, "cde"),
   X = Y.
    </pre>

    In response, we get the concrete solution:

    <pre>
   <b>X = Y, Y = c.</b>
    </pre>

    This works because upon unification, the hook is invoked, builds
    the intersection of the two domains, determines that they have
    only a single&nbsp;element in common, and hence unifies the
    resulting variable with that element. Note that <tt>X</tt>
    and <tt>Y</tt> have become completely indistinguishable.
    Unification has truly <i>unified</i> them.

    <br><br>

    <b>Exercise</b> (hard): The following property is highly desirable
      for a constraint solver. Prove that it holds in this case, or
      provide a counterexample:<br><i>For every
      Prolog&nbsp;query&nbsp;<tt>Q</tt> that consists <i>only</i>
      of <tt>domain/2</tt> and <tt>(=)/2</tt> goals, <i>removing</i>
      one of the goals makes the resulting query&nbsp;<tt>Q'</tt> at
      least as general as&nbsp;<tt>Q</tt>, in the sense that the set
      of solutions of <tt>Q</tt> is a subset of those
      of&nbsp;<tt>Q'</tt>.</i>
    </div>
    
    <center><h3>属性の表示</h3></center>

    実際の制約ソルバーでは、
    <tt>attrmod:put_atts(X,a(test))</tt>
    のような見た目の答えでは満足できません。
    制約ソルバーに期待するのはそんな表示でなく、
    <i>人間にとって意味のある</i>属性を表現した表示です。
    制約ソルバー内部でどのように実装されているかは関係なく、
    明確に定義された意味を持つ、
    より高レベルの<i>Prolog ゴール</i>を回答として生成することを期待します。

    <br><br>

    このために、
    <a href="dcg">DCG 非終端</a>の
    <tt>M:attribute_goals//1</tt>があります。
    Scryer Prolog では、モジュール<tt>M</tt>でこの非終端を定義でき、
    <tt>M</tt>に属性を持つ変数<tt>X</tt>それぞれについて自動的に
    Prolog エンジンから呼び出されます。
    これは次のような定義です:

    <br>
    <div id="attribute_goals" class="predicate">
      <tt><b>M:attribute_goals(V)</b></tt>:
      <br>
      これは、<a href="dcg">DCG非終端記号</a>で、
      モジュール<tt>M</tt>内で<tt>V</tt>に属性が
      存在する原因となった
      Prologゴールの<i>リスト</i>を記述しています。
      つまり、これらのゴールを実行すると、
      モジュール<tt>M</tt>内で<tt>X</tt>に対して
      同等の属性が生成されるべきであることを意味します。
    </div>
    <br>

    例として、上で考えた単純な有限ドメインの制約ソルバーに
    この機能を適用しましよう。
    それは<tt>domain/2</tt>という単純なインターフェース述語のみ持ちます。
    理想的には、トップレベルで表示する答えは
    ユーザに意味が知られている
    パブリックなインターフェース述語だけを使うべきです。

    <br><br>

    従って、上記の非終端を使って
    属性を<i>残余ゴール</i>（<i>residual&nbsp;goals</i>）
    と呼ばれるものに<i>変換</i>する必要があります。
    上記の具体的ケースでは、このように実行できます:

    <pre>
attribute_goals(Var) --&gt;
        (   { get_atts(Var, domain(Dom)) } -&gt;
            [domain(Var, Dom)]
        ;   []
        ).
    </pre>

    これは単純に属性を取得し、<i>単一</i>ゴールのリストを記述します。
    この述語が答えの表示の際にトップレベルから自動的に呼び出される
    様子の例です:

    <pre>
?- domain(X, "abc").
   <b>domain(X, "abc").</b>
    </pre>

    さらに複雑なクエリにも同様に動作します:

    <pre>
?- domain(X, "abc"),
   domain(Y, "bcd"),
   X = Y.
   X = Y,
   <b>domain(Y, "bc")</b>.
    </pre>

    この機構を利用して、内部属性をもっとユーザにとって意味のある
    Prolog ゴールに変換できます。

    <br><br>

    トップレベルは、この機能を述語<tt>copy_term/3</tt>を
    内部的に呼び出すことで提供します。
    この述語は、制約に関係する可能性のある変数の<i>コピー</i>を作成し、
    <tt>attribute_goals//1</tt>を使用して、呼び出されると
    コピーに同等の属性を作成する<i>ゴールのリスト</i>を作成します。
    <tt>copy_term(X, X, Gs)</tt>を使用して、
    <tt>X</tt>が関係する制約<tt>Gs</tt>について推論できます。
    ゴールの<i>リスト</i>が使用されていることに注意してください。
    これは、ゴールの<a href="data#clean">クリーンな</a>表現であり、
    さらに便利な分析を可能にするためです。

    <br><br>
    <button onclick="toggleOriginalContent('原文_displaying')">原文</button>
    <div id="原文_displaying" class="hide_on_start">
    <center><h3>Displaying attributes</h3></center>

    In an actual constraint solver, we are not content with answers
    that look like <tt>attrmod:put_atts(X,a(test))</tt>. Instead, what we
    expect from a constraint solver is a representation of remaining
    attributes that is <i>meaningful to humans</i>. Thus, we expect a
    constraint solver to emit more high-level <i>Prolog&nbsp;goals</i>
    as answers, which have a well-defined meaning no matter how they
    are internally implemented.

    <br><br>

    For this purpose, there is
    the <a href="dcg">DCG&nbsp;nonterminal</a> <tt>M:attribute_goals//1</tt>. In
    Scryer&nbsp;Prolog, you can define this nonterminal in a
    module&nbsp;<tt>M</tt>, and it is automatically invoked by the
    Prolog&nbsp;engine for each variable&nbsp;<tt>X</tt> that has an
    attribute in&nbsp;<tt>M</tt>. It is defined as follows:

    <br>
    <div id="attribute_goals" class="predicate">
      <tt><b>M:attribute_goals(V)</b></tt>:
      <br>
      This is a <a href="dcg">DCG nonterminal</a> describing
      a <i>list</i> of Prolog goals which caused the presence
      of <tt>V</tt>'s attributes in module&nbsp;<tt>M</tt>. This means
      that executing these goals should lead to equivalent attributes
      on&nbsp;<tt>X</tt> in module&nbsp;<tt>M</tt>.
    </div>
    <br>

    For example, let us apply this feature to our simple finite
    domain constraint solver that we considered above. It only has a
    single interface predicate,
    called&nbsp;<tt>domain/2</tt>. Ideally, answers that are reported
    on the toplevel should only use public interface predicates,
    since their meaning is known to&nbsp;users.

    <br><br>

    Thus, it remains for us to <i>translate</i> attributes to
    so-called <i>residual&nbsp;goals</i>, using the above nonterminal.
    In the concrete case above, we can do it like this:

    <pre>
attribute_goals(Var) --&gt;
        (   { get_atts(Var, domain(Dom)) } -&gt;
            [domain(Var, Dom)]
        ;   []
        ).
    </pre>

    This simply fetches the attribute, and describes a list with
    a <i>single</i> goal. Here is an example that illustrates that
    this predicate is automatically invoked by the toplevel when
    reporting answers:

    <pre>
?- domain(X, "abc").
   <b>domain(X, "abc").</b>
    </pre>

    It also works for more complex queries:

    <pre>
?- domain(X, "abc"),
   domain(Y, "bcd"),
   X = Y.
   X = Y,
   <b>domain(Y, "bc")</b>.
    </pre>

    Using this mechanism, you can always translate internal attributes
    to Prolog&nbsp;goals that are more meaningful to users.

    <br><br>

    The toplevel provides this functionality by internally invoking
    the predicate&nbsp;<tt>copy_term/3</tt>. This predicate creates
    a <i>copy</i> of variables that may be involved in constraints,
    and uses <tt>attribute_goals//1</tt> to create a <i>list
    of&nbsp;goals</i> that, when called, create equivalent attributes
    on the copy. You can use <tt>copy_term(X, X, Gs)</tt> to reason
    about the constraints&nbsp;<tt>Gs</tt> that <tt>X</tt> is
    involved&nbsp;in. Note that a <i>list</i> of goals is used, since
    this is a <a href="data#clean">clean</a> representation
    of&nbsp;goals that allows convenient further analysis.
    </div>

    <center><h2>落とし穴と些事</h2></center>

    属性付き変数を扱うと、エラーが発生しやすくなります。
    私の経験では、教育、研究、実践をどれだけ積んでも、
    属性付き変数を扱うときにごく基本的なミスを犯すことは避けられません。

    <br><br>

    システム実装者が、特定の種類のエラーを不可能にする
    インターフェイスを提供することで、
    Prolog プログラマーの作業をできるだけ簡単にすることが、
    なおさら重要です。
    実装者は、利便性と正確さを犠牲にしてパフォーマンスを向上させるために、
    低レベルのインターフェイスを提供したくなることがあります。

    <br><br>

    例えば、2002年に Bart Demoen は非常に影響力のある論文
    （<a href="https://pdfs.semanticscholar.org/3104/a69b2ed0bc58d67678c6b91eb3d864fe1de2.pdf"><i>Dynamic attributes, their hProlog implementation, and a first evaluation</i></a>）
    を公開しました。

    <br><br>

    Bart Demoen は
    Prolog コミュニティで非常に多作で高く評価されているメンバーであるため、
    いくつかのシステムが彼の提案したアプローチを採用しました。

    <br><br>

    彼が提案し、実装したインターフェイスは、重要な点で不十分です。
    私はその論文から引用し、重要な箇所を強調します。

    
    <blockquote class="quote">
      <b>4 基本的選択 III: <tt><i>pre_unify</i></tt>を使わない</b>

      <br><br>

      SICStus Prolog と ECLiPSe の属性付き変数の最も大きな違いは、
      単一化ハンドラが呼び出された瞬間における変数の状態です。

      <br><br>

      例えば:
      属性付き変数 X が (モジュール<tt>user</tt>において)
      ある属性 Aを持ち、X が整数 666 と単一化されたとします。
      <br>
      SICStus Prolog では<b>まだバインドされていない</b> X について
      <a href="https://sicstus.sics.se/sicstus/docs/3.7.1/html/sicstus_17.html#IDX980"><tt>verify_attributes</tt></a>
      が呼び出されます。
      <br>
      ECLiPSe では
      <b>X が既に 666 にバインドされた状態</b>で A を引数として
      単一化ハンドラが呼び出されます。

      <br><br>

      SICStus Prolog の振る舞いは
      [6] に従っており、
      <b>変数をまだバインドされていないかのようにすることが重要である</b>
      と主張しています。

      <br><br>

      一方で ECLiPSe の人々 (Joachim Schimpf) は
      <b>これは不要である</b> と主張しています。

      <br><br>

      私達はこの問題で立場を取りたくありません:
      私達はある時点で完全な SICStus Prolog の動作を実装しましたが
      (もちろん動的属性に対して)、
      実装の複雑さが余分なメリットに見合うとは確信できませんでした。
      しかし、SICStus Prolog と ECLiPSe のマニュアルには、
      <tt>pre_unify</tt>中に X をバインドすると
      予期しない結果が生じると書かれており、
      私たちは感心しませんでした。
      私たちの意見 (および経験) では、
      SICStus Prolog や ECLiPSe のような完全なシステムで
      <tt>pre_unify</tt>の完全サポートを
      実装および維持するには面倒すぎるということを示しています。
      そこで、互換性の理由から<tt>pre_unify</tt>をサポートするという妥協はせず、
      ECLiPSe モデルに切り替えました。オッカムの剃刀はありがたいものです
      :-)
    </blockquote>

    不幸にも、スマイリーがあるにも関わらず、
    この一文は Prolog 実装者に真面目なものとして受け取られてしまいました。
    現在ではこの限定されたインターフェースは、
    例えば SWI-Prolog で提供されています。

    <br><br>
    <button onclick="toggleOriginalContent('原文_pitfalls')">原文</button>
    <div id="原文_pitfalls" class="hide_on_start">
    <center><h2>Pitfalls and Errands</h2></center>

    Working with attributed variables is very error-prone.
    In my experience, no amount of education, research and practice saves
    one from making quite elementary mistakes when working with them.

    <br><br>

    It is all the more important that system&nbsp;implementors make
    the lives of Prolog programmers as easy as possible by providing
    interfaces that make certain classes of errors impossible.
    Implementors are sometimes tempted to provide low-level interfaces
    to gain performance at the cost of convenience and correctness.

    <br><br>


    For example, in 2002, Bart Demoen published a highly influential paper
    called <a href="https://pdfs.semanticscholar.org/3104/a69b2ed0bc58d67678c6b91eb3d864fe1de2.pdf"><i>Dynamic
    attributes, their hProlog implementation, and a first
        evaluation</i></a>.

    <br><br>

    Bart Demoen is an extremely prolific and highly regarded member of
    the Prolog community, and several systems therefore adopted the
    approach he proposed.

    <br><br>

    The interface he proposed and implemented deliberately falls short
    in a critical respect. I quote from the paper and highlight the
    key passages:

    <blockquote class="quote">
      <b>4 Basic choice III: no <tt><i>pre_unify</i></tt></b>

      <br><br>

      The most profound difference between attributed variables in
      SICStus Prolog and ECLiPSe is the state of the variable at the
      moment the unifcation handler is called.

      <br><br>

      As an example: assume the attributed variable&nbsp;X has one
      attribute&nbsp;A (with module <tt>user</tt>) and X is unifed
      with the integer&nbsp;666. In SICStus
      Prolog, <a href="https://sicstus.sics.se/sicstus/docs/3.7.1/html/sicstus_17.html#IDX980"><tt>verify_attributes</tt></a>
      is called with X <b>still being unbound</b>. In ECLiPSe, the
      unify handler is called with A as an argument - <b>X has been
      bound to&nbsp;666 already</b>.

      <br><br>

      The SICStus Prolog behavior follows [6] which claims that <b>it
        is important to have the variables as if not yet bound</b>.


      <br><br>

      ECLiPSe people on the other hand (Joachim Schimpf) claim <b>that
        this is not needed</b>.

      <br><br>

      We do not want to take a stand in this issue: we had implemented
      at some point the full SICStus Prolog behavior (but on dynamic
      attributes of course) and were not convinced that the extra
      implementation complexity was worth the gain. However, we were
      not impressed by the manuals of SICStus Prolog and ECLiPSe,
      which claim that <b>binding the X during a
        <tt>pre_unify</tt> yields unexpected results</b>: in our
      opinion (and experience), it just shows that full support for
      <tt>pre_unify</tt> is too cumbersome to implement and maintain
      in a full system like SICStus Prolog or ECLiPSe. So we
      switched to the ECLiPSe model, but without the compromise to
      support <tt>pre_unify</tt> for compatibility reasons: Occam's
      razor is a blessing&nbsp;:-)
    </blockquote>

    Unfortunately, despite the smiley, the above passage was taken
    seriously by Prolog implementors, and this limited interface is
    what for example SWI-Prolog now provides.
    </div>

    <center><h2>オッカムの剃刀</h2></center>

    <a href="https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%83%E3%82%AB%E3%83%A0%E3%81%AE%E5%89%83%E5%88%80">オッカムの剃刀</a>
    （<a href="https://en.wikipedia.org/wiki/Occam%27s_razor">Occam's razor</a>）
    の最もよく知られているバージョンでは、
    「必要ないならエンティティを増やしてはならない」
    （<i>"Entities are not to be multiplied without necessity"</i>）
    と述べられています。

    <br><br>

    ならば、
    <i>属性付き変数にはなぜ３つの異なるインターフェースがあり、そのうち２つは他に比べて汎用性が低いのでしょうか？</i>

    <br><br>

    保守的なアプローチとして
    Neumerkel と Holzbaur による２０年以上前の研究があります:

    <br><br>

    広く使われている４つの Prolog システム、
    SICStus, GNU-Prolog, ECLiPSe, SWI は
    ４つ種類の制約を使っています:
    <a href="optimization">CLP(H)</a>,
    <a href="clpfd">CLP(FD)</a>,
    <a href="/clpb/">CLP(B)</a>,
    <a href="https://sicstus.sics.se/sicstus/docs/3.7.1/html/sicstus_32.html">CLP(Q)</a>

    <br><br>

    SICStus はそれら４つをサポートします。<br>
    ECLiPSe と GNU-Prolog はそれらのうち２つをサポートします。<br>
    それらのシステムにおいて、
    <i>どれが一般性の高い属性付き引数インターフェースを持つのでしょうか</i>？
    そのシステムを、私たちが目指すものとして採用します。
    <i>オッカムの剃刀によるならば</i>、
    それらが提供する制約ソルバーをサポートするのに
    <i>必要なことだけを行っている</i>でしょう。

    <br><br>

    属性付き変数に対する SWI-Prolog インターフェースの根本的な欠点は、
    <tt>verify_attributes/3</tt>がサポートされておらず、
    代わりに<tt>attr_unify_hook/2</tt>と呼ばれる
    はるかに汎用性の低い述語のみが提供されていることです。
    重大なこととして、<tt>attr_unify_hook/2</tt>は、
    変数がすでに単一化された後にのみ呼び出されます。

    <br><br>

    これは、最初はまったく無害に思えるかもしれません:
    結局のところ、その変数の (前の) 属性は
    <tt>attr_unify_hook/2</tt>の引数なので、
    知る必要のあるすべての情報が利用できる、<i>ですよね</i>？
    これが事実だと仮定しましょう
    (ただし、以下で説明するように、そう<i>ではありません</i>)。
    その場合でも、たとえば<tt>[X,Y] = [0,1]</tt>のような目標を介して、
    複数の変数が一度にインスタンス化される可能性があります。
    このような単一化に<tt>n</tt>個の 変数が含まれる場合、
    一つの単一化で少なくとも 2<sup><i>n</i></sup> <i>種類</i>の
    インスタンス化パターンが発生する可能性があることは容易にわかります。
    すべてのケースを完全に考え抜くことは誰にもできません。
    同時単一化によって発生する可能性がある状況の例は、
    コミット
    <a href="https://github.com/SWI-Prolog/swipl-devel/commit/9c8ea20b7c9aa5a2b86d4bcc82a93f8f0e7b34c1">9c8ea20b7</a>
    で説明されています。
    制約プログラミングの経験豊富な専門家が、
    Prolog システムが提供する最も単純で
    最も基本的な制約の 1 つである<tt>dif/2</tt>制約の独自の実装で
    <a href="https://github.com/SWI-Prolog/issues/issues/15">同じ問題</a>
    に遭遇しました。
    数年後、 SWI-Prolog の<tt>dif/2</tt>の実装で
    <a href="https://github.com/SWI-Prolog/issues/issues/112">別の間違い</a>
    が見つかり、修正されました。
    そして
    <a href="https://github.com/SWI-Prolog/issues/issues/122"><i>別の間違い</i></a>
    が見つかって修正され、
    今日まで
    <a href="https://github.com/SWI-Prolog/issues/issues/113">非循環項についてすら</a>、
    <a href="https://github.com/SWI-Prolog/issues/issues/128">
      SWI-Prolog の<tt>dif/2</tt>は誤った実装のままです</a>。

    <br><br>

    しかしインターフェースに責任はない、そうでしょうか？
    結局のところ、下手な職人だけが<i>ツール</i>のせいにする、そうでしょうか？

    <br><br>

    <b>違います!</b>
    インターフェースはそのような間違いを可能にするのみならず、
    そのような間違いを<i>強制する</i>、ならばそのインターフェースを
    考え直すべきです。
    通常、そのような問題は真剣なインターフェース再考の十分な理由です。
    しかし、Prolog コミュニティにおいては、
    このインターフェースのエラーを誘発しやすい性質は、
    それだけでは変更の十分な理由にはなりません。
    伝統的に、最も重要なのは<i>パフォーマンス</i>であり、
    システムが高速である限り正確さなど気にしません。<i>そうでしょうか</i>？
    したがって、2 番目の議論を示します:

    <br><br>

    SWI-Prolog のインターフェースでは、
    制約ソルバーの重要なクラスを表現するのに<i>十分ではありません</i>。
    単一化<tt>[X,Y] = [0,1]</tt> について再び考えてみましょう。
    これは、<i>両方の</i>変数の属性が同時に使用できなくなることを意味します。
    確かに、<tt>attr_unify_hook/2</tt>が<tt>X</tt>に対して実行されると、
    以前の属性にアクセスできます。
    しかし、その時点では、<tt>get_attr/3</tt>経由で<tt>Y</tt>の
    以前の属性にアクセスできなくなります。
    実際、<tt>Y</tt>が変数であったことさえわからなくなります。
    次のセクションでは、これが必要であるのに不可能である例を示します。

    <br><br>

    <br><br>
    <button onclick="toggleOriginalContent('原文_occams_razor')">原文</button>
    <div id="原文_occams_razor" class="hide_on_start">
    <center><h2>Occam's razor</h2></center>

    <a href="https://en.wikipedia.org/wiki/Occam%27s_razor">Occam's
    razor</a>, in its most popular version, states that <i>"Entities
      are not to be multiplied without necessity"</i>.

    <br><br>

    I ask you, then, <i>why do we have 3 different interfaces for
    attributed variables, two of which are clearly less general than
    the other?</i>

    <br><br>

    A conservative approach, more than 20 years after the work of
    Neumerkel and Holzbaur, could look as follows:

    <br><br>

    Let us consider 4 widely used Prolog systems, such as SICStus,
    GNU-Prolog, ECLiPSe and&nbsp;SWI, and 4 widely used types of
    constraints: <a href="optimization">CLP(H)</a>, <a href="clpfd">CLP(FD)</a>,
    <a href="/clpb/">CLP(B)</a>
    and&nbsp;<a href="https://sicstus.sics.se/sicstus/docs/3.7.1/html/sicstus_32.html">CLP(Q)</a>.

    <br><br>

    SICStus supports 4 of them. SWI supports 3 of them. ECLiPSe and
    GNU-Prolog support 2 of them. Of these systems, <i>which has the
    most general interface for attributed variables</i>? Take this
    system as the one we want to strive&nbsp;towards. <i>By Occam's
    razor</i>, chances are that they have <i>only done what is
    needed</i> to support the constraint&nbsp;solvers they provide.

    <br><br>

    The core shortcoming of the SWI-Prolog interface for attributed
    variables is that <tt>verify_attributes/3</tt> is not supported,
    and only a much less general predicate
    called <tt>attr_unify_hook/2</tt> is provided instead. Critically,
    <tt>attr_unify_hook/2</tt> is only
    invoked <i>after</i> a variable has already been unified.

    <br><br>

    This may seem quite innocent at first: After all, the (previous)
    attribute of that variable is an argument
    of <tt>attr_unify_hook/2</tt>, so everything we need to know is
    available, <i>right</i>? Let us suppose that this is the case
    (although it&nbsp;<i>isn't</i>, as we discuss below). Even then,
    several variables may <i>at&nbsp;once</i> become instantiated, for
    example via a goal like <tt>[X,Y]&nbsp;=&nbsp;[0,1]</tt>. It is
    easy to see that if such a unification
    involves <tt>n</tt>&nbsp;variables, then there are at least
    2<sup><i>n</i></sup> different <i>kinds</i> of possible
    instantiation patterns that may arise in a single
    unification. Nobody is able to think all cases through completely.
    An example of a situation that can arise due to simultaneous
    unifications is explained in
    commit&nbsp;<a href="https://github.com/SWI-Prolog/swipl-devel/commit/9c8ea20b7c9aa5a2b86d4bcc82a93f8f0e7b34c1">9c8ea20b7</a>.
    A highly experienced expert in constraint programming ran into
    the <a href="https://github.com/SWI-Prolog/issues/issues/15">same&nbsp;issue</a>
    in his own implementation of the <tt>dif/2</tt> constraint, even
    though it is one of the simplest and most elementary constraints
    Prolog systems provide. A few years
    later, <a href="https://github.com/SWI-Prolog/issues/issues/105">another&nbsp;mistake</a>
    was found and corrected in the implementation of
    SWI-Prolog's <tt>dif/2</tt> constraint, then <a href="https://github.com/SWI-Prolog/issues/issues/112">another mistake</a> was found and corrected, then <a href="https://github.com/SWI-Prolog/issues/issues/122"><i>another mistake</i></a> was found and corrected, and to this day, <a href="https://github.com/SWI-Prolog/issues/issues/128"><tt>dif/2</tt>
      remains incorrectly implemented in SWI-Prolog</a>,
    <a href="https://github.com/SWI-Prolog/issues/issues/113">even for acyclic terms</a>.

    <br><br>


    But still, maybe the interface is not to blame, right? Maybe we
    have only not tried hard enough to work with the interface. After
    all, only poor craftspeople blame their&nbsp;<i>tools</i>, right?

    <br><br>

    <b>Wrong!</b> If an interface not only makes possible but
    downright <i>enforces</i> such mistakes, then it is time to
    reconsider the interface. Normally, such issues should be reason
    enough to seriously rethink the interface. However, in the Prolog
    community, the error-prone nature of this interface is not by
    itself enough reason for&nbsp;change. Traditionally, it
    is <i>performance</i> that matters&nbsp;most, and who cares about
    correctness as long as your system is&nbsp;fast, <i>right</i>?
    Therefore, I give you a second argument:

    <br><br>

    The SWI-Prolog interface is <i>not&nbsp;sufficient</i> to express
    important classes of constraint solvers. Consider again the
    unification <tt>[X,Y] = [0,1]</tt>. This means that the attributes
    of <i>both</i> variables become unavailable at the same time. It
    is true: When <tt>attr_unify_hook/2</tt> is run
    for&nbsp;<tt>X</tt>, you have access to its former attribute. But
    at that time, you can no longer access the former attribute
    of&nbsp;<tt>Y</tt> via <tt>get_attr/3</tt>, and in fact you can
    no&nbsp;longer even tell that <tt>Y</tt> was a variable. The next
    section shows an example where this is needed, but not possible.
    </div>
    <br><br>

    <center><h2 id="minatotask">湊タスク</h2></center>

    ここで、
    <a href="https://en.wikipedia.org/wiki/Zero-suppressed_decision_diagram">Zero-suppressed decision diagrams</a>(ZDD)
    に基づく
    <a href="/clpb/">CLP(B) システム</a>
    を実装するときに簡単に遭遇する特定のタスクについて考えてみましょう。

    ZDD は非常に重要なデータ構造であり、
    <a href="http://www-cs-faculty.stanford.edu/~knuth/">Donald Knuth</a>
    は
    <a href="https://www.youtube.com/watch?v=xLBvCB2kr4Q">講演</a>で
    ZDD を「コンピュータ サイエンスにおける最も美しい構造」と呼んでいます。

    <br><br>

    私はこのタスクを、 ZDD の発明者である
    <a href="http://art.ist.hokudai.ac.jp/~minato/index-j.html">湊 真一 (みなと しんいち)</a>
    に敬意を表して<b>湊タスク</b>と呼んでいます
    ( 「<a href="https://pdfs.semanticscholar.org/9593/6223362a16a50de2959475d87aefe2a1fec7.pdf"><i>Zero-Suppressed BDDs for Set Manipulation in Combinatorial Problems</i></a>」を参照)。
    このタスクを使用して、Prolog システムの属性変数の
    インターフェイス述語が、実用上非常に重要な特定のクラスの制約を
    自然に表現<i>できるほど一般的であるか</i>どうかを判断します。

    <br><br>

    ZDD は<i>決定図</i>です。
    つまり、図の線をたどるだけで真理値に到達できます。
    ZDD のノードは<i>分岐変数</i>です。
    変数が<tt>1</tt>の場合は<i>直線</i>を取り、
    変数が<tt>0</tt>の場合は<i>点線</i>を取ります。
    その点では、ZDD は<i>バイナリ決定図</i>(BDD)に似ています。
    ただし、ZDD は次のような際立ったひねりを加えて解釈されます:
    変数が<b>true</b>につながるパス上に<i>現れない</i>場合、
    その変数は<tt>0</tt>に等しくなければなりません。

    <br><br>

    たとえば、ブール関数X xor Y の真理値を表す ZDD を示します:

    <br><br>

    <center>
      <object data="xor.svg" type="image/svg+xml" style="padding:20pt">
      </object>
    </center>

    ZDD を Prolog の<a href="data#term">項</a>で表現できます。
    真理値<b>true</b>と<b>false</b>は<i>アトム</i>で表現でき、
    内部ノードは
    <tt>(&nbsp;X&nbsp;&rightarrow;&nbsp;Then&nbsp;;&nbsp;Else&nbsp;)</tt>
    で表現できます。
    ここで:

    <ul>
      <li><tt>X</tt> は <i>分岐変数</i></li>
      <li><tt>Then</tt> と <tt>Else</tt>はノード
      </li>
    </ul>

    Prolog 文法のアナロジーでは、
    <tt>Then</tt> は <tt>X</tt>が<tt>1</tt>(<b>true</b>) であることを、
    <tt>Else</tt> は <tt>X</tt>が<tt>0</tt>(<b>false</b>) であることを
    意味します。

    <br><br>

    例えば、上記 ZDD は次のように表せます:

    <pre>
( X -&gt; <b>true</b> ; ( Y -&gt; <b>true</b> ; <b>false</b> ) )
    </pre>

    <tt>X</tt> と <tt>Y</tt> 両方の変数がこの決定図に関係します。
    よって Prolog でこのような制約について推論するには、
    この図を両方の変数に<i>属性</i>として添付するのが自然です。
    <a href="#put_attr">put_attr/3</a>を使用して
    これを行う方法は次のとおりです:

    <pre>
?- ZDD = ( X -> true ; ( Y -> true ; false ) ),
   put_attr(X, zdd, ZDD),
   put_attr(Y, zdd, ZDD).
    </pre>

    ここで、一連の単一化について検討し、
    システムのインターフェース述語を使用して<tt>X</tt>と<tt>Y</tt>の
    正しい真理値に到達する方法を教えてください。

    <ol>
      <li>
        まず、次の単一化について考えます: <tt>X = 0</tt>.

        <br><br>
        あなたは例えば次のように答えます:
        それは簡単、決定図を見ると単純にそれは:

    <pre>
( 0 -> true ; ( Y -> true ; false ) )
    </pre>

    最初の分岐変数はインスタンス化されているから
    どの分岐を取るかは明確で、
    図全体を次のように置き換えることができます:

    <pre>
( Y -> true ; false )
    </pre>
    これにより、続く単一化は簡単です。

    <br><br>

      </li>


      <li>

        少しむずかしいケースです: <tt>X = 1</tt>.

        <br><br>

        これは ZDD を次のように簡略化できることを意味します:

    <pre>
true
    </pre>

    しかし待ってください。それがすべてではありません！
    説明したように、<b>true</b>へのパスに表示されない変数は
    <tt>0</tt>に等しくなければなりません。
    この場合、<tt>Y</tt> はそのような変数なので、
    <tt>0</tt>に設定する必要があります。
    しかし、どのようにすればよいのでしょうか？
    これを行う 1 つの方法は、制約にこれまで表示された
    <i>すべての変数</i>を追跡し、
    たとえば ZDD を次のような項の<i>ペア</i>として表すことです:

    <pre>
( X -&gt; true ; ( Y -&gt; true ; false ) )-<b>[X,Y]</b>
    </pre>

    これは、上記のケースが次のようになることを意味します:

    <pre>
true-[1,Y]
    </pre>

    そこから <tt>Y&nbsp;=&nbsp;0</tt> を述べるのは簡単です。

      </li>


      <li>三番目のケースです: <tt>[X,Y]&nbsp;=&nbsp;[1,1]</tt>.

        <br><br>

        た、インターフェイス述語を使用して、
        変数が関係する制約によりこの単一化が<i>許容されない</i>ことを
        どのように判断するかを示すことで、
        <b>湊タスク</b>を解決します。

        <br><br>

        比較のために、ZDD が次の例の場合には
        単一化が<i>成功する</i>必要があります:

        <pre>
ZDD = ( X -> Inner ; Inner ), Inner = ( Y -> true ; false )
        </pre>

        これは、ZDD の<i>他の</i>分岐を調べても
        <tt>Y</tt>に関する情報を回復できないことを示しています。
      </li>
    </ol>

    特に次の点に注意してください:
    この問題は、属性付き変数の非常に原始的なインターフェースでも、
    <i>何らかの方法で</i>解決できることは間違いありません。
    一つの例は、あらゆる種類の属性を複製して、
    どこにでも存在するすべてのデータ構造で
    冗長的に使用できるようにすることです。
    ただし、このような変形を要求するインターフェースは
    真剣に受け止められません。
    さらに、特に決定図で推論する場合、
    メモリが主なボトルネックになることが多いため、
    この理由からもデータのコピーは避けたいものです。

    <br><br>

    私の見解では、重要な質問は次のとおりです:

    <ul>
      <li>このようなタスクを解決するために、
        インターフェースをどの程度<i>自然に</i>使用できるか?</li>
      <li>それを使用するアプリケーションプログラマーによる
        <i>ミス</i>の可能性はどのくらいあるか？</li>
      <li>無視できるほどの追加の性能のために、
        私たちはどれだけ労力をかけられるか？</li>
    </ul>

    私の意見では、間違いが<i>可能な限り起こりにくい</i>、
    便利で<i>汎用的な</i>インターフェース述語を目指すべきです。
    人々は「SICStus インターフェースが欲しい」と言います。
    実際、私はさらに<i>強力な保証</i>を提供するインターフェースを好みます。
    しかし、現在利用可能なインターフェースの中では、
    SICStus インターフェースが最も望ましいと考えており、
    そのエミュレーションを推奨します。

    <br><br>
    <button onclick="toggleOriginalContent('原文_minato_task')">原文</button>
    <div id="原文_minato_task" class="hide_on_start">
    <center><h2 id="minatotask">Minato task</h2></center>

    Let us now consider a specific task, which is easily encountered
    when implementing a <a href="/clpb/">CLP(B)&nbsp;system</a> based
    on
    <a href="https://en.wikipedia.org/wiki/Zero-suppressed_decision_diagram">Zero-suppressed
      decision diagrams</a>&nbsp;(ZDDs). ZDDs are a very important
      data&nbsp;structure, and
    <a href="http://www-cs-faculty.stanford.edu/~knuth/">Donald&nbsp;Knuth</a>
    has called them "the most beautiful construct in
    computer&nbsp;science" in
    a&nbsp;<a href="https://www.youtube.com/watch?v=xLBvCB2kr4Q">talk</a>.

    <br><br>

    I call this task <b>Minato&nbsp;task</b>, in honor of
    <a href="http://art.ist.hokudai.ac.jp/~minato/index-j.html">
    湊　真一(みなと　しんいち)</a>, MINATO Shin-ichi, the inventor
    of&nbsp;ZDDs
    (see <a href="https://pdfs.semanticscholar.org/9593/6223362a16a50de2959475d87aefe2a1fec7.pdf"><i>Zero-Suppressed
    BDDs for Set Manipulation in Combinatorial Problems</i></a>). We
    shall use this&nbsp;task to determine whether a Prolog system's
    interface predicates for attributed variables
    are <i>general&nbsp;enough</i> to naturally express a certain
    class of constraints that are of great practical importance.

    <br><br>

    A ZDD is a <i>decision&nbsp;diagram</i>. This means that we can
    simply follow the lines of the diagram to arrive at a
    truth&nbsp;value. The nodes of a&nbsp;ZDD
    are <i>branching&nbsp;variables</i>: If a variable
    is&nbsp;<tt>1</tt>, then we take the <i>plain</i>&nbsp;line, and
    if a variable is&nbsp;<tt>0</tt>, then we take
    the <i>dotted</i>&nbsp;line. In that respect, a ZDD is like
    a <i>Binary Decision Diagram</i>&nbsp;(BDD). However, a ZDD is
    interpreted with the following distinguishing&nbsp;twist: If a
    variable does <i>not</i>&nbsp;appear on a path that leads
    to&nbsp;<b>true</b>, then that variable must be equal
    to&nbsp;<tt>0</tt>.

    <br><br>

    For example, here is a ZDD that represents the truth value
    of the Boolean function <i>X</i>&nbsp;<tt>xor</tt>&nbsp;<i>Y</i>:

    <br><br>

    <center>
      <object data="xor.svg" type="image/svg+xml" style="padding:20pt">
      </object>
    </center>

    We can represent a ZDD as a
    Prolog <a href="data#term">term</a>. The truth
    values <b>true</b> and <b>false</b> can be represented
    as <i>atoms</i>, and an inner node can be represented as
    <tt>(&nbsp;X&nbsp;&rightarrow;&nbsp;Then&nbsp;;&nbsp;Else&nbsp;)</tt>,
    where:

    <ul>
      <li><tt>X</tt> is a <i>branching variable</i></li>
      <li><tt>Then</tt> and <tt>Else</tt> are nodes.
      </li>
    </ul>

    In analogy to Prolog syntax, <tt>Then</tt> is taken to mean
    that <tt>X</tt> is&nbsp;<tt>1</tt> (<b>true</b>), and <tt>Else</tt> means
    that <tt>X</tt> is&nbsp;<tt>0</tt> (<b>false</b>).

    <br><br>

    For example, the ZDD above can be represented as:

    <pre>
( X -&gt; <b>true</b> ; ( Y -&gt; <b>true</b> ; <b>false</b> ) )
    </pre>

    Both variables, <tt>X</tt> and <tt>Y</tt>, participate in this
    decision diagram. Therefore, to reason about such constraints in
    Prolog, it is natural to attach this diagram as
    an <i>attribute</i> to both variables. Here is how we can do this
    with <a href="#put_attr">put_attr/3</a>:

    <pre>
?- ZDD = ( X -> true ; ( Y -> true ; false ) ),
   put_attr(X, zdd, ZDD),
   put_attr(Y, zdd, ZDD).
    </pre>

    We now consider a series of unifications, and you tell us how you
    use your system's interface predicates to arrive at the correct
    truth values for <tt>X</tt> and <tt>Y</tt>.

    <ol>
      <li>
        As a start, consider the following unification: <tt>X = 0</tt>.

        <br><br>
        You reply for example with: That's easy, I simply take a look at
        the decision diagram, which now is:

    <pre>
( 0 -> true ; ( Y -> true ; false ) )
    </pre>

    Since the first branching variable is now instantiated, it is
    clear which branch we must take, so we can replace the whole diagram with:

    <pre>
( Y -> true ; false )
    </pre>
    From there, further unifications are easy.

    <br><br>

      </li>


      <li>

        Here is a slightly harder case: <tt>X = 1</tt>.

        <br><br>

        This means that the ZDD could be reduced to:

    <pre>
true
    </pre>

    But wait, that's not all! As we explained, a variable that
    does <i>not</i> appear in a path to <b>true</b> must be equal
    to&nbsp;<tt>0</tt>. In this case, <tt>Y</tt> is such a variable,
    so we must set it to&nbsp;<tt>0</tt>. But&nbsp;how? Well, one way
    to do this is to keep track of <i>all&nbsp;variables</i> that have
    so far appeared in constraints, and to represent the ZDD for
    example as a <i>pair</i> of terms, such as:

    <pre>
( X -&gt; true ; ( Y -&gt; true ; false ) )-<b>[X,Y]</b>
    </pre>

    This means that in the above case, we would end up with:

    <pre>
true-[1,Y]
    </pre>

    and from there it is easy to state that <tt>Y&nbsp;=&nbsp;0</tt>.

      </li>


      <li>Here is a third case: <tt>[X,Y]&nbsp;=&nbsp;[1,1]</tt>.

        <br><br>

        And you solve the <b>Minato task</b> by telling us how your
        interface predicates can be used to determine that this
        unification is <i>not&nbsp;admissible</i> due to the
        constraints the variables are involved&nbsp;in.

        <br><br>

        For comparison, the unification must <i>succeed</i> if the ZDD
        is for example:

        <pre>
ZDD = ( X -> Inner ; Inner ), Inner = ( Y -> true ; false )
        </pre>

        This illustrates that you cannot look into <i>other</i>
        branches of the&nbsp;ZDD to recover any information
        about&nbsp;<tt>Y</tt>.
      </li>
    </ol>

    Note especially the following: There is no doubt that this issue
    can be solved <i>somehow</i>, even with a very primitive interface
    for attributed variables. One example would be to duplicate all
    kinds of attributes so that they are available redundantly in all
    data structures that occur anywhere. However, an interface that
    demands such contortions cannot be taken seriously. In addition,
    and especially when reasoning with decision diagrams, memory is
    often the primary bottleneck, and we therefore want to avoid
    copying&nbsp;data also for this&nbsp;reason.

    <br><br>

    In my&nbsp;view, the key&nbsp;questions
    are:

    <ul>

      <li>How <i>naturally</i> can an interface be used to solve
        such&nbsp;tasks?</li>

      <li>How likely are <i>mistakes</i> by application programmers
        who use it?</li>

      <li>How hard do we want to make our lives for the sake of
        negligible additional performance?</li>
    </ul>

    In my opinion, we should strive for convenient and <i>general</i>
    interface predicates that make mistakes <i>as unlikely as
    possible</i>. People have suggested that I "want the SICStus
    interface". I would in fact prefer an interface that
    provides <i>even stronger guarantees</i>. However, from those
    interfaces that are currently available, I consider the SICStus
    interface the most desirable, and therefore recommend its
    emulation.
    </div>

    <center><h3 id="minatotask_sicstus">SICStus Prolog でのソリューション</h3></center>

    完全を期すために、
    SICStus Prolog の属性付き変数の非常に一般的な
    <a href="https://sicstus.sics.se/sicstus/docs/3.7.1/html/sicstus_17.html#IDX980">インターフェース</a>
    を使用した、
    湊タスクについて取りうるソリューションを次に示します。

    <br><br>

    まず、次のようなノードの
    <a href="data#clean"><i>クリーン</i></a>な
    表現を使用します:

    <ul>
      <li><i>葉</i>は <tt>b(true)</tt> または <tt>b(false)</tt></li>
      <li><i>内部ノード</i>は<tt>( Var -&gt; Then ; Else )</tt>、
      ここで <tt>Then</tt> と<tt>Else</tt>はノード</li>
    </ul>

    特に、具体的なブール値に使用する<tt>b/1</tt>ラッパーのおかげで、
    葉と内部ノードを<i>記号的に</i>区別できるようになったことに
    注目してください。

    <br><br>

    準備として、ZDD のいわゆる<b>制限</b>を表現しましょう。
    これは、1 つの ZDD と、
    変数<tt>Var</tt>が
    具体的なブール値の真理値<tt>Value</tt>
    (<tt>0</tt>または<tt>1</tt>のいずれか)と単一化されたときに発生する
    新しい ZDD との関係を意味します。

    <pre>
zdd_restriction(b(T), _, _, b(T)).
zdd_restriction(( Var0 -&gt; Then0 ; Else0), Var, Value, ZDD) :-
        (   Var0 == Var -&gt;
            (   Value =:= 0 -&gt; ZDD = Else0
            ;   Value =:= 1 -&gt; ZDD = Then0
            ;   throw(no_boolean)
            )
        ;   zdd_restriction(Then0, Var, Value, Then),
            zdd_restriction(Else0, Var, Value, Else),
            ZDD = ( Var0 -&gt; Then ; Else )
        ).
    </pre>

    クエリ例:

    <pre>
?- zdd_restriction((X -> b(true) ; b(false)), X, 1, ZDD).
<b>ZDD = b(true).</b>
    </pre>

    上記の方法は、ZDD の制限を計算する方法としては
    非常に非効率的であることに注意してください。
    <a href="/prolog/memoization"><b>メモ化</b></a>を使用して
    高速化する方法については、演習として残しておきます。

    <br><br>

    ソリューションがどのように機能するかを示すために、
    一つのパブリック述語が必要です:
    <tt><b>variables_set_zdd(Vs, ZDD)</b></tt>
    は、指定された ZDD を<tt>Vs</tt>内のすべての変数に
    <i>属性</i>として添付します。
    属性は<tt>zdd_vs(ZDD, Vs)</tt>の形式であり、
    ZDD と推論するすべての変数を格納します。

    <br><br>

    SICStus Prolog では、<tt>library(atts)</tt> を使用して
    属性を宣言し、推論します。例えば:

    <pre>
:- use_module(library(atts)).

:- attribute zdd_vs/2.

variables_set_zdd(Vs, ZDD) :-
        maplist(set_zdd(ZDD, Vs), Vs).

set_zdd(ZDD, Vs, V) :-
        put_atts(V, +zdd_vs(ZDD, Vs)).
    </pre>

    これで、<tt>verify_attributes/3</tt>を実装する準備が整いました。
    ZDD が葉ノード<tt>b(true)</tt>に縮小されると、
    その分岐で遭遇しなかったすべての変数は
    <tt>0</tt>でなければなりません。
    残りの変数ごとに一つずつ、<tt>V=0</tt>の
    目標のリストを記述する<a href="dcg">DCG</a>を使用して
    これを強制します:

    <pre>
verify_attributes(Var, Value, Goals) :-
        (   get_atts(Var, +zdd_vs(ZDD0,Vs)) -&gt;
            (   integer(Value) -&gt;
                zdd_restriction(ZDD0, Var, Value, ZDD)
            ;   throw(aliasing_not_implemented)
            ),
            phrase(remaining_vars_0(ZDD, Var, Vs), Goals)
        ;   Goals = []
        ).

remaining_vars_0(b(true), Var, Vs) --&gt; all_others_0(Vs, Var).
remaining_vars_0((_;_), _, _) --&gt; [].

all_others_0([], _) --&gt; [].
all_others_0([V|Vs], Var) --&gt;
        (   { var(V), V \== Var } -&gt; [V=0]
        ;   []
        ),
        all_others_0(Vs, Var).
    </pre>

    完全なコードはこちらから利用可能です:
    <a href="minatotask.pl"><tt>minatotask.pl</tt></a>

    <br><br>

    いくつかのサンプルクエリが含まれています。
    特に、湊タスクは期待どおりに動作します:

    <pre>
?- ZDD = ( X -&gt; b(true) ; ( Y -&gt; b(true) ; b(false) ) ),
   Vs = [X,Y],
   variables_set_zdd(Vs, ZDD),
   Vs = [1,1].
<b>no</b>
    </pre>

    汎用的で宣言的な SICStus インターフェースは、
    より限定されたフックと比較して、
    パフォーマンスにいくらか影響を与えることは明らかです。
    しかし、その汎用性に加えて、
    SICStus Prolog は<i>最も効率的な</i>Prolog システムの一つとしても
    広く知られています。
    したがって、効率のために正確さを犠牲にすべきだという議論は、
    たとえそれが理にかなったものであったとしても、
    この場合には<i>当てはまりません</i>。

    <br><br>
    <button onclick="toggleOriginalContent('原文_with_sicstus_prolog')">原文</button>
    <div id="原文_with_sicstus_prolog" class="hide_on_start">
    <center><h3 id="minatotask_sicstus">Solution with SICStus Prolog</h3></center>

    For completeness, here is a possible solution of the
    Minato&nbsp;task, using SICStus&nbsp;Prolog and its very
    general <a href="https://sicstus.sics.se/sicstus/docs/3.7.1/html/sicstus_17.html#IDX980">interface</a>
    for attributed&nbsp;variables.

    <br><br>

    First, of course, let us use
    a <a href="data#clean"><i>clean</i></a> representation of nodes, such as:

    <ul>
      <li>a <i>leaf</i> is represented as <tt>b(true)</tt> or <tt>b(false)</tt></li>
      <li>an <i>inner node</i> is represented as <tt>( Var -&gt; Then
          ; Else )</tt>, where <tt>Then</tt> and <tt>Else</tt> are nodes.
      </li>
    </ul>

    Note in particular that we can now <i>symbolically</i> distinguish
    leaves from inner&nbsp;nodes, thanks to the <tt>b/1</tt> wrapper
    we use for concrete Boolean&nbsp;values.

    <br><br>

    As a warm-up, let us express the so-called <b>restriction</b> of
    a&nbsp;ZDD. This means the relation between one&nbsp;ZDD, and a
    new&nbsp;ZDD that arises when the variable&nbsp;<tt>Var</tt> is
    unified with the concrete Boolean truth value&nbsp;<tt>Value</tt>,
    which is either <tt>0</tt> or&nbsp;<tt>1</tt>:

    <pre>
zdd_restriction(b(T), _, _, b(T)).
zdd_restriction(( Var0 -&gt; Then0 ; Else0), Var, Value, ZDD) :-
        (   Var0 == Var -&gt;
            (   Value =:= 0 -&gt; ZDD = Else0
            ;   Value =:= 1 -&gt; ZDD = Then0
            ;   throw(no_boolean)
            )
        ;   zdd_restriction(Then0, Var, Value, Then),
            zdd_restriction(Else0, Var, Value, Else),
            ZDD = ( Var0 -&gt; Then ; Else )
        ).
    </pre>

    Example query:

    <pre>
?- zdd_restriction((X -> b(true) ; b(false)), X, 1, ZDD).
<b>ZDD = b(true).</b>
    </pre>

    Note that the above method is an extremely inefficient way to
    compute the restriction of a&nbsp;ZDD. Making it faster by
    using <a href="/prolog/memoization"><b>memoization</b></a> is left as an
    exercise.

    <br><br>

        We need a single public predicate to demonstrate how our solution
    works: <tt><b>variables_set_zdd(Vs, ZDD)</b></tt> shall attach the
    given&nbsp;ZDD as an <i>attribute</i> to all variables
    in&nbsp;<tt>Vs</tt>. The attribute shall be of the
    form&nbsp;<tt>zdd_vs(ZDD, Vs)</tt> and store the&nbsp;ZDD as well
    as all variables we want to reason about.

    <br><br>

    In SICStus Prolog, we use <tt>library(atts)</tt> to declare and
    reason about attributes. For example:

    <pre>
:- use_module(library(atts)).

:- attribute zdd_vs/2.

variables_set_zdd(Vs, ZDD) :-
        maplist(set_zdd(ZDD, Vs), Vs).

set_zdd(ZDD, Vs, V) :-
        put_atts(V, +zdd_vs(ZDD, Vs)).
    </pre>

    We are now ready to implement <tt>verify_attributes/3</tt>. When a
    ZDD is reduced to the leaf&nbsp;node&nbsp;<tt>b(true)</tt>, then
    all variables that were not encountered in that branch must
    be&nbsp;<tt>0</tt>. We enforce this with
    a&nbsp;<a href="dcg">DCG</a> that describes a list of <tt>V=0</tt>
    goals, one for each remaining variable:

    <pre>
verify_attributes(Var, Value, Goals) :-
        (   get_atts(Var, +zdd_vs(ZDD0,Vs)) -&gt;
            (   integer(Value) -&gt;
                zdd_restriction(ZDD0, Var, Value, ZDD)
            ;   throw(aliasing_not_implemented)
            ),
            phrase(remaining_vars_0(ZDD, Var, Vs), Goals)
        ;   Goals = []
        ).

remaining_vars_0(b(true), Var, Vs) --&gt; all_others_0(Vs, Var).
remaining_vars_0((_;_), _, _) --&gt; [].

all_others_0([], _) --&gt; [].
all_others_0([V|Vs], Var) --&gt;
        (   { var(V), V \== Var } -&gt; [V=0]
        ;   []
        ),
        all_others_0(Vs, Var).
    </pre>

    The full code is available from: <a href="minatotask.pl"><tt>minatotask.pl</tt></a>

    <br><br>

    A few sample queries are included. In particular, the
    Minato&nbsp;task works as desired:

    <pre>
?- ZDD = ( X -&gt; b(true) ; ( Y -&gt; b(true) ; b(false) ) ),
   Vs = [X,Y],
   variables_set_zdd(Vs, ZDD),
   Vs = [1,1].
<b>no</b>
    </pre>

    It is clear that the general and declarative SICStus interface has
    some performance impact in comparison with more
    limited&nbsp;hooks. However, in addition to its generality,
    SICStus&nbsp;Prolog is also widely known as one of
    the <i>most&nbsp;efficient</i> Prolog&nbsp;systems.  The argument
    that we should sacrifice correctness for efficiency, even if it
    were a sensible&nbsp;one, can therefore <i>not</i> be applied in
    this case.
    </div>

    <center><h2 id="equivalencetask">同等性タスク</h2></center>

    ここで、私が<b>同等性タスク</b>（<b>Equivalence&nbsp;task</b>）と呼ぶ
    ２番目のタスクについて考えます。
    このタスクも<a href="/clpb/">CLP(B)</a>に関連して発生します。
    このタスクが、システムのインターフェース述語の
    一般性と表現力を評価するのに役立つことを願っています。

    <br><br>

    <a href="https://sicstus.sics.se/sicstus/docs/4.3.5/html/sicstus/CLPB-Interface.html#CLPB-Interface">SICStus ドキュメント</a>
    には、<tt>Expression</tt> が充足できる場合にのみ true となる
    <tt>sat(Expression)</tt> について、以下のように記載されています:

    <blockquote class="quote">
      式に現れる  変数<tt>X</tt>が
      何らかの項<tt>T</tt>と単一化される場合、
      これは制約の省略形として扱われる

<pre>
| ?- sat(X=:=T).
</pre>
    </blockquote>
    <br><br>

    これを Prolog で実装するには、
    属性付き変数のインターフェースが、単一化実行<i>前に</i>
    単一化について推論する能力を持っている必要があります。
    ここでも、異なる実装戦略では、非常に不自然で
    エラーが発生しやすいエンコードが必要になります。

    <br><br>

    例として次のクエリを考えます:

    <pre>
?- sat(X=:=Z), X = X+1.
    </pre>

    これをシステムでどのように処理できるか考えてみてください。
    SICStus のドキュメントによると、これは次のコードと同等です:

    <pre>
?- sat(X=:=Z), sat(X=:=X+1).
    </pre>

    これは<i>充足</i>可能であることから、例えば次のようになるはずです:

    <pre>
<b>X = Z, Z = 1.</b>
    </pre>

    システムがそのような答えを生成できない場合は、
    適切な近似値とはどのようなものか、またそれをどのように
    計算できるかを考えてください。

    <br><br>

    たとえば、属性付き変数のインターフェース述語を使用して、
    少なくとも上記のケースを次のケースと<i>区別</i>できますか:

    <pre>
?- sat(X=:=Z), X = ~X.
    </pre>

    これは次と同等です:

    <pre>
?- sat(X=:=Z), sat(X =:= ~X).
    </pre>

    そして<i>失敗</i>します。

    <br><br>
    <button onclick="toggleOriginalContent('原文_equivalence_task')">原文</button>
    <div id="原文_equivalence_task" class="hide_on_start">
    <center><h2 id="equivalencetask">Equivalence task</h2></center>

    We now consider a second task, which I
    call <b>Equivalence&nbsp;task</b>, and which also arises in
    connection with&nbsp;<a href="/clpb/">CLP(B)</a>. I hope this task
    is useful for&nbsp;you to assess the generality and expressiveness
    of your system's interface predicates.

    <br><br>

    The
    <a href="https://sicstus.sics.se/sicstus/docs/4.3.5/html/sicstus/CLPB-Interface.html#CLPB-Interface">SICStus&nbsp;documentation</a>
    states for <tt>sat(Expression)</tt>, which is
    true <i>iff</i> <tt>Expression</tt> is satisfiable:

    <blockquote class="quote">
      If a variable&nbsp;<tt>X</tt>, occurring in the expression, is
    subsequently unified with some term&nbsp;<tt>T</tt>, this is
    treated as a shorthand for the constraint

<pre>
| ?- sat(X=:=T).
</pre>
    </blockquote>
    <br><br>

    To implement this in Prolog, an interface for attributed variables
    must have the ability to reason about a unification <i>before</i>
    it takes&nbsp;place. Again, a different implementation strategy
    necessitates highly unnatural and error-prone encodings.

    <br><br>

    Consider for example the query:

    <pre>
?- sat(X=:=Z), X = X+1.
    </pre>

    and ask yourself how this could be handled in your system.
    According to the SICStus&nbsp;documentation, it should be
    equivalent to:

    <pre>
?- sat(X=:=Z), sat(X=:=X+1).
    </pre>

    This is <i>satisfiable</i> and should therefore yield for example:

    <pre>
<b>X = Z, Z = 1.</b>
    </pre>

    If your system cannot yield such an answer, think about what a
    suitable approximation may look&nbsp;like, and how it can be
    computed.

    <br><br>

    For example, with your interface predicates for attributed
    variables, can you at least somehow <i>distinguish</i> the above
    case from:

    <pre>
?- sat(X=:=Z), X = ~X.
    </pre>

    which ought to be equivalent to:

    <pre>
?- sat(X=:=Z), sat(X =:= ~X).
    </pre>

    and hence <i>fail</i>.
    </div>

    <center><h2>さらなる読み物と今後の取り組み</h2></center>

    属性付き変数は通常、Prolog 上に
    制約ソルバーを実装するために使用されます。
    これは最も重要な使用例ですが、<i>唯一</i>の使用例ではありません。

    <br><br>

    特に、破壊的な割り当てや
    <a href="optimization#graph"><i>グラフ</i></a>
    についての推論が必要な Prolog プログラムの場合、
    属性付き変数は多くの場合、適切で便利な表現です。
    ただし、破壊的な割り当てに夢中にならないでください。
    コードの関係性が破壊されるためです。

    <br><br>

    良い方法は、ライブラリのより
    宣言的なインターフェイス述語の背後に
    属性付き変数の使用を<i>カプセル化</i>することです。
    たとえば、グラフの いわゆる<i>強連結部分</i>を見つけるための
    Tarjan アルゴリズムの実装
    <a href="/scc.pl"><tt><b>scc.pl</b></tt></a>
    を考えてみましょう。
    その場合、属性付き変数を使用すると、
    漸近的に最適なパフォーマンスに近いアルゴリズムを実装できます。

    <br><br>

    私は、査読済みの出版物
    <a href="/swiclpb.pdf"><i><b>The Boolean Constraint Solver of SWI-Prolog</b></i></a>
    (2016) と拡張されたジャーナルバージョンの
    <a href="/boolean.pdf"><i><b>Boolean Constraints in SWI-Prolog: Aprehensive system description</b></i></a>
    (2018) でいくつかの問題について説明しました。

    <br><br>

    私にとって、属性付き変数のインターフェース述語の現状は、
    せいぜい、間違いなく<i>さらなる作業</i>に値するものと言えます。
    たとえば、<i>異なる</i>制約ソルバーがそれぞれのドメインの交差点で
    <i>連携</i>できるようにするには、どのような方法が最適でしょうか？

    <br><br>

    新しいインターフェース述語について良いアイデアをお持ちの場合は、
    低レベルの変更を必要とせずに既存の Prolog システムを拡張することで、
    コミュニティにメカニズムを提示できる
    <a href="/acomip/">メタインタープリター</a>
    の作成を検討してください。
    または、Douglas Miles の例に倣って、
    <a href="https://github.com/SWI-Prolog/roadmap/issues/14">既存のエンジンを直接拡張</a>
    してください。

    <br><br>
    <button onclick="toggleOriginalContent('原文_further_reading')">原文</button>
    <div id="原文_further_reading" class="hide_on_start">
    <center><h2>Further reading and future work</h2></center>

    Attributed variables are typically used to implement constraint
    solvers on top of&nbsp;Prolog. This is their most important, but
    not their <i>only</i> use&nbsp;case.

    <br><br>

    Especially for Prolog programs that need destructive assignments
    or reason about <a href="optimization#graph"><i>graphs</i></a>,
    attributed variables are often a good and convenient
    representation. Do not get carried away with destructive
    assignment though, because it destroys the relational nature of
    your&nbsp;code.

    <br><br>

    A good approach is to <i>encapsulate</i> the use of attributed
    variables behind more declarative interface predicates of
    your&nbsp;libraries. For example, consider the implementation of
    Tarjan's&nbsp;algorithm to find the
    so-called <i>Strongly&nbsp;Connected Components</i> of
    a&nbsp;graph:&nbsp;<a href="/scc.pl"><tt><b>scc.pl</b></tt></a>. In
    that case, the use of attributed variables allows us to implement
    the algorithm with close to asymptotically <i>optimal</i>
    performance.

    <br><br>

    I have described some of the issues in the peer-reviewed
    publication <a href="/swiclpb.pdf"><i><b>The Boolean Constraint
    Solver of SWI-Prolog</b></i></a>&nbsp;(2016), and in the extended
    journal version <a href="/boolean.pdf"><i><b>Boolean Constraints
    in SWI-Prolog: A comprehensive system
    description</b></i></a>&nbsp;(2018).

    <br><br>

    To me, the current state of interface predicates for
    attributed&nbsp;variables can at best be considered as definitely
    deserving <i>much additional work</i>. For instance, what would be
    the best way to let <i>different</i> constraint
    solvers <i>cooperate</i> in the intersection of their domains?

    <br><br>

    If you have a good idea for new interface predicates, consider
    writing a
    <a href="/acomip/">meta-interpreter</a> that lets you present the
    mechanism to the community by extending an existing
    Prolog&nbsp;system without the need for low-level
    changes. Alternatively, follow the example of Douglas&nbsp;Miles
    and <a href="https://github.com/SWI-Prolog/roadmap/issues/14">extend
    an existing engine directly</a>.
    </div>

    <br><br><br>
    <b><a href="/prolog">More about Prolog</a></b>

    <br><br><br>

    <b><a href="/">Main page</a></b>
    <script src="jquery.js"></script>
    <script src="toc.js"></script>
  </body>
</html>
