<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Basic Concepts</title>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="description" content="Basic Concepts">
    <meta name="keywords" content="Prolog,Concepts,Basics,Introduction">
    <meta name="author" content="Markus Triska">
    <link rel="stylesheet" type="text/css" href="prolog.css">
    <link rel="stylesheet" type="text/css" href="toc.css">
    <script>
      document.addEventListener("DOMContentLoaded", function() {
          var all_hide_on_start = document.getElementsByClassName('hide_on_start');
          for (var i = 0, m = all_hide_on_start.length; i < m; i++) {
              var element = all_hide_on_start[i];
              element.style.display = "none";
          }
      });
      function toggleOriginalContent(id) {
          var element = document.getElementById(id);
          if (element.style.display === "none") {
              element.style.display = "block";
          } else {
              element.style.display = "none";
          }
      }
    </script>
  </head>
  <body style="padding-left: 5%; padding-right: 5%; padding-bottom: 3cm">

    <br><br>
    <br><br>
    <center><h1>基本概念</h1></center>

    Prologの最も基本的な<b>概念</b>を紹介し、定義します。

    <br><br>
    <button onclick="toggleOriginalContent('原文_basic_concepts')">原文</button>
    <div id="原文_basic_concepts" class="hide_on_start">
    <br><br>
    <br><br>
    <center><h1>Basic Concepts</h1></center>
    <br>

    We introduce and define the most basic <b>concepts</b> of Prolog.
    </div>
    <center><h2>項（Terms）</h2></center>

    Prologでは、<i>すべてのデータ</i>—Prolog<i>プログラム</i>を含めて
    —がPrologの<a href="data#term"><b>項（terms）</b></a>で表されます。

    <br><br>
    <button onclick="toggleOriginalContent('原文_terms')">原文</button>
    <div id="原文_terms" class="hide_on_start">
    <center><h2>Terms</h2></center>

    In Prolog, <i>all data</i>&mdash;including
    Prolog <i>programs</i>&mdash;are represented by
    Prolog <a href="data#term"><b>terms</b></a>.
    </div>

    <center><h2 id="program">プログラム（Programs）</h2></center>

    Prologの<b>プログラム</b>は、<i>述語</i>の集まりです。

    <br><br>

    述語は、引数間の<b>関係</b>を定義します。
    論理的には、Prologプログラムは何が<i>成り立つ</i>のかを示します。

    <br><br>

    Prologプログラムの<a href="writing"><b>書き方</b></a>には
    いくつかの慣習があり、また異なる<a href="reading"><b>読み方</b></a>も存在します。

    <br><br>
    <button onclick="toggleOriginalContent('原文_programs')">原文</button>
    <div id="原文_programs" class="hide_on_start">
    <center><h2 id="program">Programs</h2></center>

    A Prolog <b>program</b> is a set of <i>predicates</i>.

    <br><br>

    Predicates define <b>relations</b> between their
    arguments. Logically, a Prolog program states what&nbsp;<i>holds</i>.

    <br><br>

    There are a few conventions
    for <a href="writing"><b>writing</b></a> Prolog programs, and
    different ways of <a href="reading"><b>reading</b></a> them.
    </div>

    <center><h3 id="predicate">述語（Predicates）</h3></center>

    <b>述語</b>には<i>名前</i>があり、0個以上の<i>引数</i>を持ちます。
    述語の<b>名前</b>はPrologの<i>アトム</i>です。各<b>引数</b>は任意のPrologの項です。

    <br><br>

    述語<i>Pred</i>と<i>N</i>個の引数を持つ述語は、<i>Pred</i>/<i>N</i>と表記され、
    これを<b>述語指標</b>と呼びます。
    <i>N</i>は述語の<b>アリティ（項数）</b>です。

    <br><br>

    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="videos/predicates"><img src="videos/t_predicates.png" alt="Predicates"></a></td>
      </tr>
    </table>

    <br><br>

    述語は<i>節</i>の集まりによって定義されます。

    <br><br>

    <div id="clause">
      <b>節（clause）</b>は、<i>ルール</i>または<i>事実（ファクト）</i>のいずれかです。
      述語を構成する節は論理的な<i>選択肢</i>を示します。
      つまり、<i>いずれか</i>の節が真であれば、その述語全体が真となります。
    </div>

    <br><br>
    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="videos/clauses"><img src="videos/t_clauses.png" alt="Clauses, Rules and Facts"></a></td>
      </tr>
    </table>

    <br><br>
    <button onclick="toggleOriginalContent('原文_predicates')">原文</button>
    <div id="原文_predicates" class="hide_on_start">
    <center><h3 id="predicate">Predicates</h3></center>

    Each <b>predicate</b> has a <i>name</i>, and zero or
    more <i>arguments</i>. The predicate <b>name</b> is a
    Prolog&nbsp;<i>atom</i>. Each <b>argument</b> is an arbitrary
    Prolog&nbsp;term.

    <br><br>

    A predicate with name <i>Pred</i> and <i>N</i> arguments is
    denoted by <i>Pred</i>/<i>N</i>, which is called
    a <b>predicate&nbsp;indicator</b>. <i>N</i> is called
    the <b>arity</b> of the predicate.

    <br><br>

    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/predicates"><img src="videos/t_predicates.png" alt="Predicates"></a>
        </td>
      </tr>
    </table>

    <br><br>

    A predicate is defined by a collection of <i>clauses</i>.

    <br><br>

    <div id="clause">
      A <b>clause</b> is either a <i>rule</i> or a <i>fact</i>. The
      clauses that constitute a predicate denote
      logical <i>alternatives</i>: If <i>any</i> clause is true, then
      the whole predicate is&nbsp;true.
    </div>

    <br><br>
    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/clauses"><img src="videos/t_clauses.png" alt="Clauses, Rules and Facts"></a>
        </td>
      </tr>
    </table>
    </div>

    <center><h3 id="rule">ルール（Rules）</h3></center>

    Prologの<b>ルール</b>は次の形式を持ちます：

    <pre>
<i>Head</i> :- <i>Body</i>.
    </pre>

    ルールの<b>頭部（Head）</b>の表記は、引数の数によって異なります：

    <ul>
      <li>述語に<i>引数がない</i>場合、頭部は述語名だけで構成されます。</li>
      <li>述語<i>Name</i>が<i>N</i>個の正の引数を持つ場合、頭部は次のように書かれます：
        <tt><i>Name</i>(<i>Arg</i><sub>1</sub>, <i>Arg</i><sub>2</sub>, ..., <i>Arg</i><sub>N</sub>)</tt>
      </li>
    </ul>

    各ルールの<b>本体（Body)</b>はPrologの<i>ゴール</i>です。

    <br><br>

    <b>ゴール</b>は、述語とその引数を表すPrologの項です。

    <br><br>

    ルールが<b>再帰的</b>である場合、そのゴールの一つが
    ルールが定義している述語を参照しています。

    <br><br>
    <button onclick="toggleOriginalContent('原文_rules')">原文</button>
    <div id="原文_rules" class="hide_on_start">
    <center><h3 id="rule">Rules</h3></center>

    A Prolog <b>rule</b> has the form:

    <pre>
<i>Head</i> :- <i>Body</i>.
    </pre>

    The notation of the <b>head</b> of a rule depends on the number of
    arguments:

    <ul>
      
      <li>If the predicate has <i>zero</i>
	arguments, then the head consists only of the predicate name.</li>
      <li>If a predicate called <i>Name</i> has a <i>positive</i>
	number&nbsp;<i>N</i> of arguments, then the head is written
	as:
<tt><i>Name</i>(<i>Arg</i><sub>1</sub>, <i>Arg</i><sub>2</sub>, ..., <i>Arg</i><sub>N</sub>)</tt>.
      </li>
    </ul>

    The <b>body</b> of each rule is a Prolog <i>goal</i>.

    <br><br>
    
    A <b>goal</b> is a Prolog term that denotes a predicate and its arguments.

    <br><br>

    A rule is called <b>recursive</b> if one of its goals refers to
    the predicate that the rule is defining.
    </div>

    <center><h3 id="fact">事実（ファクト）</h3></center>

    <b>事実（ファクト）</b>は次のように書かれます：
    <pre>
<i>Head</i>.
    </pre>

    これは次の<a href="#rule">ルール</a>と同等です：

    <pre>
<i>Head</i> :- <b>true</b>.
    </pre>

    論理的には、これは組み込み述語<tt>true/0</tt>が常に真であるため、
    ルールが<i>常に成立する</i>ことを意味します。

    <br><br>
    <button onclick="toggleOriginalContent('原文_facts')">原文</button>
    <div id="原文_facts" class="hide_on_start">

    <center><h3 id="fact">Facts</h3></center>

    A <b>fact</b> is written as:

    <pre>
<i>Head</i>.
    </pre>

    This is equivalent to the <a href="#rule">rule</a>:
    
    <pre>
<i>Head</i> :- <b>true</b>.
    </pre>

    Logically, this means that the rule <i>always&nbsp;holds</i>,
    because the <a href="#builtin">built-in</a>
    predicate <tt>true/0</tt> is always&nbsp;true.
    </div>

    <center><h2 id="toplevel">トップレベル（Toplevel）</h2></center>

    Prologの<b>トップレベル</b>は、Prologプログラムを<i>実行</i>する主要な方法です。

    <br><br>

    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="videos/toplevel"><img src="videos/t_toplevel.png" alt="The Prolog Toplevel"></a></td>
      </tr>
    </table>

    <br><br>

    Prolog述語を呼び出すには、トップレベルで<b>クエリ</b>を投入します。
    クエリは任意のPrologの<i>ゴール</i>です。クエリ内の変数は<i>存在論的</i>に量化されます。
    したがって、クエリは次のように解釈できます：
    「与えられた述語が<i>成り立つ</i>ケースは存在するか？」

    <br><br>
    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="videos/queries"><img src="videos/t_queries.png" alt="Queries"></a></td>
      </tr>
    </table>

    <br><br>

    クエリに対する応答として、トップレベルは<b>答え</b>を報告します。
    答えはクエリと宣言的に<i>同等</i>のPrologのゴールです。

    <br><br>

    各述語には関連する<b>最も一般的なクエリ</b>があり、
    これは「すべての引数が新しい変数である」ことを意味します。

    <br><br>
    ゴールは<i>複数回成功する</i>ことがあります。
    Prologの実装によって、<tt>スペース</tt>または「;」を押すと選択肢を表示できます。

    <br><br>
    <button onclick="toggleOriginalContent('原文_toplevel')">原文</button>
    <div id="原文_toplevel" class="hide_on_start">
    <center><h2 id="toplevel">Toplevel</h2></center>


    The Prolog <b>toplevel</b> is the main way in which we <i>run</i>
    Prolog programs.

    <br><br>

    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/toplevel"><img src="videos/t_toplevel.png" alt="The Prolog Toplevel"></a>
        </td>
      </tr>
    </table>

    <br><br>

    We invoke a Prolog predicate by posting a <b>query</b> on the
    toplevel. A query is an arbitrary Prolog&nbsp;<i>goal</i>. In a
    query, variables are <i>existentially</i> quantified. We can thus
    read a query as: "Are there any cases for which the given
    predicate&nbsp;<i>holds</i>?"

    <br><br>
    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/queries"><img src="videos/t_queries.png" alt="Clauses, Rules and Facts"></a>
        </td>
      </tr>
    </table>

    <br><br>

    In response to a query, the toplevel reports an <b>answer</b>.
    The answer is a Prolog goal that is
    declaratively <i>equivalent</i> to the query.

    <br><br>

    Every predicate has an associated <b>most general query</b>, which
    means that <i>all arguments are fresh&nbsp;variables</i>.

    <br><br>

    Note that a goal can succeed <i>more than once</i>. Depending on
    your Prolog implementation, you either press <tt>SPACE</tt>
    or&nbsp;";" to see alternatives.
    </div>

    <center><h2>Prologコードの実行</h2></center>

    Prologプログラムの実行は、
    <a href="https://ja.wikipedia.org/wiki/%E5%B0%8E%E5%87%BA%E5%8E%9F%E7%90%86"><b>導出</b></a>
    （<a href="https://en.wikipedia.org/wiki/Resolution_(logic)"><b>resolution</b></a>）
    </a>の特別なケースと見なすことができます。
    解決法は形式論理に根ざしたアルゴリズムです。
    論理的には、Prologがクエリに答えるとき、それは否定されたクエリとプログラムを構成する一連の節の<i>解決による否定</i>を見つけようとします。
    解決が見つかると、そのクエリがプログラムの論理的<b>結果</b>であることを意味します。

    <br><br>

    重要なステップの一つが、項の構文的<b>単一化（unification）</b>です。
    単一化は<i>パターンマッチング</i>の一般化です。
    節の頭部がPrologのゴールと単一化されるために選ばれると、
    単一化は両者の引数に適用されます。

    <br><br>

    このため、<a href="purity">純粋な</a>述語において、
    入力引数と出力引数の<i>区別はありません</i>。
    Prolog述語はしばしば複数の方向で使用できます。

    <br><br>

    複数の節頭部がゴールと単一化する場合、
    <b>バックトラッキング</b>によって選択肢が試されます。

    <br><br>

    非公式には、Prologのデフォルトの実行戦略
    （これは<i>深さ優先探索と逐次的バックトラッキング</i>と呼ばれます）は、
    他の言語で使用できる<i>関数呼び出し</i>の一般化と考えることができます。
    主な違いは、(1)複数の節が一致することがあり、(2)単一化が双方向に機能する点です。

    <br><br>

    Prologプログラムは<i>異なる</i>実行戦略で解釈することができ、
    それを柔軟に選択できます。
    <a href="memoization#tabling">SLG解決法</a>は、Prologシステムで増えつつある
    代替の実行戦略の一つです。
    プログラムを変更することなく異なる実行戦略を使用できることは、
    Prologの大きな魅力の一つです。

    <br><br>

    Prologプログラムの間違いを見つけるには、実際の実行ステップを追跡する必要は
    <i>通常ありません</i>。
    代わりに、論理的推論によって間違いを絞り込むための
    <a href="debugging"><b>宣言的デバッグ</b></a>手法を適用できます。

    <br><br>
    <button onclick="toggleOriginalContent('原文_running')">原文</button>
    <div id="原文_running" class="hide_on_start">
    <center><h2>Running Prolog code</h2></center>

    Running a Prolog program can be regarded as a special case
    of <a href="https://en.wikipedia.org/wiki/Resolution_(logic)"><b>resolution</b></a>, which is an algorithm that is rooted in
    formal&nbsp;logic. Logically, when Prolog answers a query, it
    tries to find a <i>resolution&nbsp;refutation</i> of the negated
    query and the set of clauses that constitute the program. When a
    refutation is found, it means that the query is a
    logical <b>consequence</b> of the program.

    <br><br>

    An important step in this process is syntactic <b>unification</b>
    of terms. Unification is a generalization of <i>pattern
    matching</i>. When a clause head is chosen for unification with a
    Prolog goal, then unification applies to the arguments
    of&nbsp;<i>both</i>.

    <br><br>

    For this reason, there is <i>no distinction</i> between input and
    output arguments of <a href="purity">pure</a> predicates, and
    Prolog predicates can often be used in several directions.

    <br><br>

    If multiple clause heads unify with a goal, then alternatives are
    tried on <b>backtracking</b>.

    <br><br>

    Informally, you can think of Prolog's default execution strategy,
    which is called <i>depth-first search with chronological
    backtracking</i>, as a generalization
    of <i>function&nbsp;calls</i> that are available in other
    languages. The main differences are that: (1)&nbsp;multiple
    clauses can match and (2)&nbsp;unification works in both
    directions.

    <br><br>

    A Prolog&nbsp;program can be interpreted with <i>different</i>
    execution strategies that can be flexibly
    selected. <a href="memoization#tabling">SLG&nbsp;resolution</a>
    is an alternative execution strategy that is available in an
    increasing number of Prolog&nbsp;systems. The ability to use
    different execution strategies while keeping the program unchanged
    is a major attraction of Prolog.

    <br><br>
    To find mistakes in Prolog programs,
    it is typically <i>not necessary</i> to trace the actual execution
    steps. Instead, <a href="debugging"><b>declarative
    debugging</b></a> techniques can be applied to narrow down
    mistakes by logical reasoning.
    </div>

    <center><h2 id="builtin">ビルトイン述語</h2></center>

    Prologシステムを開始すると、いくつかの述語は既に<i>事前に定義</i>されています。
    これらは<i>ビルトイン述語</i>または単に<b>ビルトイン</b>と呼ばれます。

    <br><br>

    例えば、ビルトインの<tt>(=)/2</tt>は、その引数が<i>単一化</i>する場合に真となります。
    ビルトインの<tt>true/0</tt>は常に<i>真</i>であり、<tt>false/0</tt>は常に<i>偽</i>です。

    <br><br>

    多くのビルトインは、<i>便利さ</i>のために存在しており、
    上述のメカニズムを使って簡単に自分で定義することができます。
    例えば、もしそれらが既に定義されていなければ、次のように述語を定義できます。

    <pre>
T = T.

true.

false :- a = b.
    </pre>

    しかし、すべてのビルトインがこの方法で定義できるわけではありません。

    <br><br>

    <tt>(=)/2</tt>、<tt>true/0</tt>、<tt>false/0</tt>に加えて、
    有用で純粋なPrologプログラムを書くために知っておくべき
    最も重要なビルトインは次の通りです：

    <ul>
      <li> <tt>dif/2</tt>はその引数が<i>異なる</i>項である場合に真となります</li>
      <li> <a href="clpz"><b>整数制約</b></a>は、算術式に関する推論を可能にします</li>
      <li> <tt>(',')/2</tt>は<b>論理積</b>（AND）を表します：<tt>(A,B)</tt>は<tt>A</tt>と<tt>B</tt>の両方が真である場合に真です</li>
      <li> <tt>(';')/2</tt>は<b>論理和</b>（OR）を表します：<tt>(A;B)</tt>は<tt>A</tt>または<tt>B</tt>、あるいは両方が真である場合に真です。</li>
    </ul>

    <br><br>
    <button onclick="toggleOriginalContent('原文_built_ins')">原文</button>
    <div id="原文_built_ins" class="hide_on_start">
    <center><h2 id="builtin">Built-ins</h2></center>

    Some predicates are already <i>predefined</i> when you start your
    Prolog&nbsp;system. These are
    called <i>built-in</i>&nbsp;predicates or
    simply&nbsp;<b>built-ins</b>.

    <br><br>

    For example, the built-in <tt>(=)/2</tt> is true <i>iff</i> its
    arguments <i>unify</i>. The built-in <tt>true/0</tt> is
    always <i>true</i>, and the built-in <tt>false/0</tt> is
    always <i>false</i>.

    <br><br>

    Many built-ins are only available for <i>convenience</i>, and you
    could easily define them yourself by the mechanisms explained
    above. For example, if they were not already defined, you could
    define the mentioned predicates as:

    <pre>
T = T.

true.

false :- a = b.
    </pre>

    However, not all built-ins can be defined in this way.

    <br><br>

    In addition to <tt>(=)/2</tt>, <tt>true/0</tt>
    and <tt>false/0</tt>, the most important built-ins you need to
    know to write useful and pure Prolog programs are:

    <ul>
      <li> <tt>dif/2</tt> is true <i>iff</i> its arguments are <i>different</i> terms</li>
      <li> <a href="clpz"><b>integer constraints</b></a> let you reason about arithmetic expressions</li>
      <li> <tt>(',')/2</tt> denotes <b>conjunction</b>: <tt>(A,B)</tt> is true <i>iff</i> both <tt>A</tt> <i>and</i> <tt>B</tt> are true</li>
      <li> <tt>(';')/2</tt> denotes <b>disjunction</b>: <tt>(A;B)</tt> is true <i>iff</i> either <tt>A</tt> <i>or</i> <tt>B</tt> <i>or</i> both are true.</li>
    </ul>
    </div>

    <hr>
    <center><h2 id="collatz">例: コラッツ予想</h2></center>

    これまでの概念を、次の例を用いて説明します。

    <blockquote>
      任意の正の整数<i>N</i>を取ります。
      次の整数を得るには、次の手順を実行します：
      <ul>
        <li><i>N</i>が<i>偶数</i>なら、<i>N</i>を2で割ります。</li>
        <li><i>N</i>が<i>奇数</i>なら、<i>N</i>に3を掛けて1を足します
          （3&times;<i>N</i>&nbsp;+&nbsp;1）。</li>
      </ul>
      この操作を無限に繰り返すと、
      <i>N</i><sub>0</sub>, <i>N</i><sub>1</sub>, <i>N</i><sub>2</sub>,&nbsp;...
      という<i>hailstone(雹)の連鎖</i>が得られます。

      <br><br>

      <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">コラッツ予想</a>
      は、<i>すべて</i>の正の初期整数に対して、
      この連鎖に整数<b>1</b>が現れるというものです。
    </blockquote>

    雹の連鎖を次のようにモデル化します。
    このとき、整数の<i>等式</i>を表すために、
    ビルトインの<a href="clpz"><b>整数制約</b></a> <tt>(#=)/2</tt>を使用します。

    <pre>
hailstone(N, N).
hailstone(N0, N) :-
        N0 #= 2*N1,
        hailstone(N1, N).
hailstone(N0, N) :-
        N0 #= 2*_ + 1,
        N1 #= 3*N0 + 1,
        hailstone(N1, N).
    </pre>

    この<b>述語</b> <tt>hailstone/2</tt>は、
    1つの<b>ファクト</b>と
    2つの<b>規則</b>からなる
    3つの<b>節</b>によって定義されています。
    これは2つの<b>引数</b>の間に<b>関係</b>を定義しています。
    最初の引数は連鎖の現在の要素を表し、
    2番目の引数は解を報告するために使用されます。
    <b>クエリ</b>を投稿し、<b>トプレベル</b>によって<b>答え</b>が報告された後、
    <b>バックトラッキング</b>により<i>代替</i>が試行されます。
    <pre>
?- hailstone(3, N).
   N = 3
;  N = 10
;  N = 5
;  N = 16
;  N = 8
;  N = 4
;  N = 2
;  N = 1
;  N = 4
;  N = 2
;  N = 1
;  ... .
    </pre>

    この<b>プログラム</b>は、一連の操作を連続する
    <i>状態</i>間の関係としてモデル化できることを示しています。
    他の例については<a href="/tist/"><i>Thinking in States</i></a>を参照してください。

    <br><br>

    純粋な関係に特徴的なのは、この述語が<i>すべての方向</i>で使用できることです。
    例えば、最も一般的な<b>クエリ</b>を投稿することができます。

    <pre>
?- hailstone(X, Y).
   X = Y
;  clpz:(2*Y#=X)
;  clpz:(2*Y#=_A), clpz:(2*_A#=X)
;  clpz:(2*_A#=X), clpz:(2*Y#=_B), clpz:(2*_B#=_A)
;  ... .
    </pre>

    Prolog述語を学ぶときは、最も一般的なクエリを試して、
    <i>一般的に</i>どのような答えが得られるかを確認してみてください。

    <br><br>

    <tt>hailstone/2</tt>を
    <a href="metapredicates#if_3"><tt>if_/3</tt></a>
    を使ってより効率的に実装できます。

    <br><br>
    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="videos/collatz"><img src="videos/t_collatz.png" alt="コラッツ予想"></a></td>
      </tr>
    </table>

    <br><br><br>
    <b><a href="/prolog">Prologについてもっと知る</a></b>

    <br><br><br>

    <b><a href="/">メインページ</a></b>

    <br><br>
    <button onclick="toggleOriginalContent('原文_collatz')">原文</button>
    <div id="原文_collatz" class="hide_on_start">
    <center><h2 id="collatz">Example: Collatz conjecture</h2></center>

    We illustrate all these concepts by means of an example:

    <blockquote>
      Take any positive integer <i>N</i>. To get the next integer,
      do the following:
      <ul>
        <li>If <i>N</i> is <i>even</i>, divide it by 2.</li>
        <li>If <i>N</i> is <i>odd</i>, multiply it by 3 and add 1,
          obtaining 3&times;<i>N</i>&nbsp;+&nbsp;1.
        </li>
      </ul>
      Repeat this indefinitely to obtain the <i>hailstone
      sequence</i> <i>N</i><sub>0</sub>, <i>N</i><sub>1</sub>, <i>N</i><sub>2</sub>,&nbsp;...

      <br><br>

      The <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz
          conjecture</a> is that the integer&nbsp;<b>1</b> appears in
      this sequence for <i>all</i> positive initial integers.
    </blockquote>

    We can model the hailstone sequence as follows, using the
    built-in <a href="clpz"><b>integer
    constraint</b></a>&nbsp;<tt>(#=)/2</tt> to denote <i>equality</i>
    of two integer&nbsp;expressions:

    <pre>
hailstone(N, N).
hailstone(N0, N) :-
        N0 #= 2*N1,
        hailstone(N1, N).
hailstone(N0, N) :-
        N0 #= 2*_ + 1,
        N1 #= 3*N0 + 1,
        hailstone(N1, N).
    </pre>

    The <b>predicate</b> <tt>hailstone/2</tt> is defined by
    three <b>clauses</b>: one <b>fact</b> and two <b>rules</b>. It
    defines a <b>relation</b> between two <b>arguments</b>. The first
    argument represents the current element of the sequence. The
    second argument is used to report solutions. After a <b>query</b>
    is posted and an <b>answer</b> is reported by the <b>toplevel</b>,
    the <i>alternatives</i> are tried on <b>backtracking</b>:

    <pre>
?- hailstone(3, N).
   N = 3
;  N = 10
;  N = 5
;  N = 16
;  N = 8
;  N = 4
;  N = 2
;  N = 1
;  N = 4
;  N = 2
;  N = 1
;  ... .
    </pre>

    This <b>program</b> illustrates that a sequence of actions can be modeled
    as a relation between successive <i>states</i>.
    See <a href="/tist/"><i>Thinking in States</i></a> for more examples.

    <br><br>

    As is characteristic for pure relations, the predicate can be used
    in <i>all directions</i>. For example, we can post the <b>most
    general query</b>:

    <pre>
?- hailstone(X, Y).
   X = Y
;  clpz:(2*Y#=X)
;  clpz:(2*Y#=_A), clpz:(2*_A#=X)
;  clpz:(2*_A#=X), clpz:(2*Y#=_B), clpz:(2*_B#=_A)
;  ... .
    </pre>

    When studying a Prolog predicate, try the most general query to see
    what answers look like <i>in&nbsp;general</i>.

    <br><br>

    We can implement <tt>hailstone/2</tt> more efficiently
    with&nbsp;<a href="metapredicates#if_3"><tt>if_/3</tt></a>.

    <br><br>
    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/collatz"><img src="videos/t_collatz.png" alt="Collatz Conjecture"></a>
        </td>
      </tr>
    </table>

    <br><br><br>
    <b><a href="/prolog">More about Prolog</a></b>

    <br><br><br>

    <b><a href="/">Main page</a></b>
    </div>
    <script src="jquery.js"></script>
    <script src="toc.js"></script>
  </body>
</html>
