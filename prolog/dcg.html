<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Prolog DCG Primer</title>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="description" content="Introduction to Prolog Definite Clause Grammars (DCGs)">
    <meta name="keywords" content="Prolog,DCG,Definite Clause Grammar">
    <meta name="author" content="Markus Triska">
    <link rel="stylesheet" type="text/css" href="prolog.css">
    <link rel="stylesheet" type="text/css" href="toc.css">
    <script>
      document.addEventListener("DOMContentLoaded", function() {
          var all_hide_on_start = document.getElementsByClassName('hide_on_start');
          for (var i = 0, m = all_hide_on_start.length; i < m; i++) {
              var element = all_hide_on_start[i];
              element.style.display = "none";
          }
      });
      function toggleOriginalContent(id) {
          var element = document.getElementById(id);
          if (element.style.display === "none") {
              element.style.display = "block";
          } else {
              element.style.display = "none";
          }
      }
    </script>
  </head>

  <body style="padding-left: 5%; padding-right: 5%; padding-bottom: 3cm">
    <br><br>

    <center><h1>Prolog DCG入門</h1></center>

    <br><br>
    <button onclick="toggleOriginalContent('原文_dcg')">原文</button>
    <div id="原文_dcg" class="hide_on_start">
    <center><h1>Prolog DCG Primer</h1></center>
    <br><br>
    </div>
    
    <center><h2>導入</h2></center>

    Prologの<b>確定節文法</b>（<b>definite clause grammar</b>、DCG）は、
    <i>シーケンス</i>を記述します。
    操作的には、DCGを使用して、リストの形式で現れるシーケンスを
    <i>解析</i>、<i>生成</i>、<i>補完</i>、および<i>検証</i>
    することができます。

    <br><br>

    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="videos/dcgs"><img src="videos/t_dcgs.png" alt="Definite Clause Grammars (DCGs)"></a></td>
      </tr>
    </table>

    <br><br>

    DCGはPrologにとって非常に重要です。
    歴史的には、Prologは自然言語処理のために
    設計されたシステムから生まれ、効率的な解析を行いつつ、
    Prologの論理的特性を保つためのメカニズムが
    開発の重要なマイルストーンとなりました。
    実用的には、DCGはリストを記述するためによく使われ、
    その利便性が高く評価されています。

    <br><br>
    DCGは<i>ルール</i>で定義されます。<b>DCGルール</b>は以下の形式を持ちます:

    <pre>
Head --&gt; Body.
    </pre>

    ルールの<i>本体</i>は、ターミナル、非ターミナル、そして
    文法ゴールで構成されます。
    <b>ターミナル</b>とはリストのことで、その中に含まれる要素、
    すなわち文法の<i>終端記号</i>を表します。
    <b>非ターミナル</b>はDCGまたは他の文法構造を指し、
    記述する要素を表し、終端記号のシーケンスを意味します。
    <b>文法ゴール</b>は中括弧で囲まれた<tt>{ Goal }</tt>の形式で書かれ、
    文法内でPrologゴールを呼び出すために使用されます。

    非ターミナル指標<i><tt>A//N</tt></i>は、
    引数が<tt>N</tt>個の非ターミナル<tt>A</tt>を指し、
    これはPrologの
    <a href="concepts#predicate"><i>述語指標</i></a>
    とは<tt>//</tt>で区別されます。

    <br><br>

    例えば、すべての要素がアトム<tt>a</tt>である
    シーケンスを記述しましょう。
    これを表すために、非ターミナル<tt>as//0</tt>を使用します:

    <pre>
as --&gt; [].
as --&gt; [a], as.
    </pre>

    最初のルールは、空のシーケンスがこの条件を満たすことを意味します。
    2つ目のルールは非ターミナル<tt>(',')//2</tt>を使っており、
    これは「<i>そして</i>」と読まれます。
    つまり、このルールは
    「最初の要素がアトム<tt>a</tt>であり、
    <i>そして</i>残りの要素もすべてアトム<tt>a</tt>である
    シーケンスもこの条件を満たす」
    と述べています。

    <br><br>

    文法ルールを呼び出すためには、Prologの組み込み述語
    <tt>phrase/2</tt>を使用します。
    最初の引数は文法の<i>ボディ</i>を記述します。
    <tt>phrase(Body, Ls)</tt>は、<tt>Body</tt>が
    リスト<tt>Ls</tt>を記述している場合に真となります。

    <br><br>

    例えば、単一の非ターミナル<tt>as//0</tt>を使用して、
    すべての解を求める最も一般的なクエリを投稿すると、
    次のようになります:

    <pre>
?- phrase(as, Ls).
<b>   Ls = []
;  Ls = [a]
;  Ls = [a,a]
;  Ls = [a,a,a]
;  Ls = [a,a,a,a]
;  ... .</b>
    </pre>

    Prologでは、<tt>double_quotes</tt>フラグを<tt>chars</tt>に設定すると、
    <i>文字</i>のリスト、すなわち<a href="data#string">文字列</a>を
    より便利に表現できます。これを行うには、以下のクエリを投稿します:

    <pre>
?- set_prolog_flag(double_quotes, chars).
<b>   true.</b>
    </pre>

    または、次のディレクティブを初期化ファイルやプログラムに追加します:

    <div>
      <pre class="box">:- set_prolog_flag(double_quotes, chars).</pre>
    </div>

    プログラム、クエリ、および解答の可読性を向上させるために、
    この設定を使用することを強くお勧めします。
    Scryer PrologやTau Prologでは、この設定が既定値になっています。

    <br><br>

    <tt>double_quotes</tt>を<tt>chars</tt>に設定すると、
    リスト<tt>[a,a,a]</tt>は<tt>"aaa"</tt>と等価に記述でき、
    Prologシステムは次のようによりコンパクトな形で解を報告する場合もあります:

    <pre>
?- phrase(as, Ls).
<b>   Ls = []
;  Ls = "a"
;  Ls = "aa"
;  Ls = "aaa"
;  Ls = "aaaa"
;  ... .</b>
    </pre>

    このテキストでは、
    <tt>double_quotes</tt> フラグが <tt>chars</tt> に設定されていると仮定します。

    <br><br>

    より具体的なクエリの例とシステムの回答:

    <pre>
?- phrase(as, "aaa").
<b>   true</b>
;  false.

?- phrase(as, "bcd").
<b>   false.</b>

?- phrase(as, [a,X,a]).
<b>   X = a</b>
;  false.
    </pre>

    <br><br>
    <button onclick="toggleOriginalContent('原文_introduction')">原文</button>
    <div id="原文_introduction" class="hide_on_start">
    <center><h2>Introduction</h2></center>

    A Prolog <b>definite clause grammar</b> (DCG) describes
    a <i>sequence</i>. Operationally, DCGs can be used
    to <i>parse</i>, <i>generate</i>, <i>complete</i> and <i>check</i>
    sequences manifested as <a href="data#list">lists</a>.

    <br><br>

    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/dcgs"><img src="videos/t_dcgs.png" alt="Definite Clause Grammars (DCGs)"></a>
        </td>
      </tr>
    </table>

    <br><br>

    DCGs are of great significance for Prolog: From a
    historical perspective, Prolog originated from systems that were
    designed for natural language processing, and a built-in mechanism
    for efficient parsing that also preserves Prolog's logical
    characteristics was one of the most important milestones in its
    development. From a practical perspective, DCGs are frequently
    used to describe lists because they are so convenient to&nbsp;use.

    <br><br>
    A DCG is defined by <i>rules</i>. A <b>DCG rule</b> has the form:

    <pre>
Head --&gt; Body.
    </pre>

    A rule's <i>body</i> consists of terminal, nonterminals, and
    grammar&nbsp;goals. A <b>terminal</b> is a list, and stands for
    the elements it&nbsp;contains. These elements are
    <i>terminal&nbsp;symbols</i> of the grammar. A <b>nonterminal</b>
    refers to a DCG or other grammar construct, and stands for the
    elements it describes. A nonterminal therefore stands for a
    sequence of terminal&nbsp;symbols. A <b>grammar&nbsp;goal</b> is
    written in curly&nbsp;brackets as <tt>{&nbsp;Goal&nbsp;}</tt> and
    is used to invoke Prolog&nbsp;goals within a grammar.
    
    We use the <i>nonterminal indicator</i>&nbsp;<tt>A//N</tt> to
    refer to the nonterminal&nbsp;<tt>A</tt> with
    arity&nbsp;<tt>N</tt>. Note that&nbsp;<tt>//</tt> distinguishes it
    from a
    Prolog <a href="concepts#predicate"><i>predicate&nbsp;indicator</i></a>.

    <br><br>

    As an example of a DCG, let us describe sequences whose every element
    is the atom&nbsp;<tt>a</tt>. We shall use the
    nonterminal&nbsp;<tt>as//0</tt> to refer to such sequences:

    <pre>
as --&gt; [].
as --&gt; [a], as.
    </pre>

    The first rule states: The empty sequence is such a sequence. The second
    rule uses the nonterminal <tt>(',')//2</tt>, which we read as
    "<i>and&nbsp;then</i>". Therefore, the second rule states: A sequence
    that contains as its first element the atom&nbsp;<tt>a</tt> <i>and
    then</i> only atoms&nbsp;<tt>a</tt> is also such a sequence.

    <br><br>

    To invoke a grammar rule, we use Prolog's
    built-in <tt>phrase/2</tt> predicate. The first argument is,
    syntactically, a DCG&nbsp;<i>body</i>. <tt>phrase(Body,
    Ls)</tt> is true iff&nbsp;<tt>Body</tt> describes the
    list&nbsp;<tt>Ls</tt>.

    <br><br>

    For example, let us use the single nonterminal&nbsp;<tt>as//0</tt>
    to ask for all lists that it describes, by posting
    the <a href="concepts#toplevel">most general query</a>:

    <pre>
?- phrase(as, Ls).
<b>   Ls = []
;  Ls = [a]
;  Ls = [a,a]
;  Ls = [a,a,a]
;  Ls = [a,a,a,a]
;  ... .</b>
    </pre>

    Prolog lets us write lists of <i>characters</i>,
    i.e., <a href="data#string">strings</a>, very conveniently if the
    Prolog flag <tt>double_quotes</tt> is set to <tt>chars</tt>, for
    example by posting the query:

    <pre>
?- set_prolog_flag(double_quotes, chars).
<b>   true.</b>
    </pre>

    or by adding the following directive in your initialisation file
    or program:

    <div>
      <pre class="box">:- set_prolog_flag(double_quotes, chars).</pre>
    </div>

    We strongly recommend using this setting for better readability
    of programs, queries and answers. In Scryer&nbsp;Prolog and
    Tau&nbsp;Prolog, this is already the default setting.

    <br><br>

    With <tt>double_quotes</tt> set to <tt>chars</tt>, the list of
    characters <tt>[a,a,a]</tt> can be written equivalently
    as <tt>"aaa"</tt>, and a Prolog system may therefore report the
    solutions above equivalently and more compactly as:

    <pre>
?- phrase(as, Ls).
<b>   Ls = []
;  Ls = "a"
;  Ls = "aa"
;  Ls = "aaa"
;  Ls = "aaaa"
;  ... .</b>
    </pre>

    Throughout this text, we assume that the Prolog
      flag <tt>double_quotes</tt> is set to <tt>chars</tt>.

    <br><br>

    Examples of more specific queries and the system's answers:

    <pre>
?- phrase(as, "aaa").
<b>   true</b>
;  false.

?- phrase(as, "bcd").
<b>   false.</b>

?- phrase(as, [a,X,a]).
<b>   X = a</b>
;  false.
    </pre>
    </div>

    <center><h2><tt>seq//1</tt>、<tt>seqq//1</tt>、および <tt>...//0</tt> を使ったシーケンスの記述</h2></center>

    ノンターミナル <tt>seq//1</tt> を定義して、
    要素のシーケンスを記述しましょう。
    引数として渡すリストが記述するシーケンスになります:

    <div>
      <pre class="box">
seq([])     --&gt; [].
seq([E|Es]) --&gt; [E], seq(Es).</pre>
    </div>

    使用例:

    <pre>
?- phrase(("Hello, ",seq(Cs),"!"), "Hello, all!").
<b>   Cs = "all"</b>
;  false.
    </pre>

    DCGをリストの<i>生成</i>のみに使用する場合、
    <tt>seq//1</tt> を次のように定義したくなるかもしれません:

    <pre>
badseq(Ls) --&gt; Ls.
    </pre>

    これは次のようなケースでは問題なく動作します:

    <pre>
?- phrase(badseq("abc"), Ls).
<b>   Ls = "abc".</b>
    </pre>

    しかし、以下の二つの理由から、この定義は推奨されません。
    まず第一に、これは他の方向で使用できず、したがって純粋な関係ではありません:

    <pre>
?- phrase(badseq(Ls), "abc").
<b>   error(instantiation_error,phrase/3).</b>
    </pre>

    第二に、このような単純な定義は、
    引数として <tt>{Goal}</tt> を指定することで
    任意のコードを実行することができます。
    例えば:

    <pre>
?- phrase(badseq({halt}), _).
    </pre>

    これら２つの理由から、DCGを使って任意のリストを参照するには、
    上記のような <tt>seq//1</tt> の定義を使用する方が良いです。

    <br><br>

    <tt>seq//1</tt> を使って、<tt>seqq//1</tt> を定義して
    シーケンスのシーケンスを記述することができます:

    <div>
      <pre class="box">
seqq([]) --&gt; [].
seqq([Es|Ess]) --&gt;
        seq(Es),
        seqq(Ess).</pre>
    </div>

    使用例:

    <pre>
?- phrase(seqq(["ab","cd","ef"]), Ls).
<b>   Ls = "abcdef".</b>
    </pre>

    これは、任意の数のリストの<i>連結</i>を記述する優れた方法です。

    <br><br>

    「任意のシーケンス」を記述するのが便利な場合があり、
    これをノンターミナル <tt>...//0</tt> を使って行うことができます。
    これは <tt>seq(_)</tt> と同等です:

    <div>
      <pre class="box">... --&gt; [] | [_], ... .</pre>
    </div>

    文法構造 <tt>('|')//2</tt> およびその同等の
    <tt>(;)//2</tt> は、Prolog の制御構造 <tt>(;)/2</tt> に対応し、
    「または」として読みます。
    DCG で解析する際は、<tt>('|')/2</tt> の使用が、
    文法を書く際の既存の慣習により推奨されます。

    <br><br>

    <tt>seq//1</tt>、<tt>seqq//1</tt>、および <tt>...//0</tt> は
    非常に多用途なノンターミナルで、
    リストに関する多くのタスクを優雅に解決するために使用できます。
    例えば、リストの最後の要素を以下のように記述できます:

    <pre>
?- phrase((...,[Last]), "hello").
<b>   Last = o</b>
;  false.
    </pre>

    もう一つの例として、リスト内で連続して繰り返される要素を
    以下のように記述できます:

    <pre>
?- phrase((...,[E,E],...), Ls).
<b>   Ls = [E,E]
;  Ls = [E,E,_A]
;  Ls = [E,E,_A,_B]
;  Ls = [E,E,_A,_B,_C]
;  ... .</b>
    </pre>

    反復深化を使うことで、<i>公平な</i>な解の列挙を得ることができます:

    <pre>
?- length(Ls, _), phrase((...,[E,E],...), Ls).
<b>   Ls = [E,E]
;  Ls = [E,E,_A]
;  Ls = [_A,E,E]
;  Ls = [E,E,_A,_B]
;  Ls = [_A,E,E,_B]
;  Ls = [_A,_B,E,E]
;  ... .</b>
    </pre>

    Scryer Prolog では、
    <tt>seq//1</tt>、<tt>seqq//1</tt> および <tt>...//0</tt> が
    <a href="https://github.com/mthom/scryer-prolog/blob/master/src/lib/dcgs.pl"><tt>library(dcgs)</tt></a>
    によって提供されています。

    <br><br>
    <button onclick="toggleOriginalContent('原文_seq')">原文</button>
    <div id="原文_seq" class="hide_on_start">
    <center><h2>Describing sequences with <tt>seq//1</tt>, <tt>seqq//1</tt> and <tt>...&nbsp;//0</tt></h2></center>

    Let us define the nonterminal <tt>seq//1</tt> to describe a
    sequence of elements. We use its single argument to refer to the
    sequence that it describes, represented as a list:

    <div>
      <pre class="box">
seq([])     --&gt; [].
seq([E|Es]) --&gt; [E], seq(Es).</pre>
    </div>

    Sample use case:

    <pre>
?- phrase(("Hello, ",seq(Cs),"!"), "Hello, all!").
<b>   Cs = "all"</b>
;  false.
    </pre>

    Note that in cases where we use DCGs only to <i>generate</i>
    lists, you might be tempted to define <tt>seq//1</tt> as follows:

    <pre>
badseq(Ls) --&gt; Ls.
    </pre>

    This still works as expected in cases like:

    <pre>
?- phrase(badseq("abc"), Ls).
<b>   Ls = "abc".</b>
    </pre>

    However, it is still not a good idea for two reasons: First, it
    cannot be used in the other direction and is thus not a pure
    relation:

    <pre>
?- phrase(badseq(Ls), "abc").
<b>   error(instantiation_error,phrase/3).</b>
    </pre>

    Second, such a simplistic definition can be tricked into invoking
    arbitrary code by specifying <tt>{Goal}</tt> as the argument, as
    in:

    <pre>
?- phrase(badseq({halt}), _).
    </pre>

    For these two reasons, it is better to use the definition
    of <tt>seq//1</tt> shown above to refer to arbitrary lists
    with&nbsp;DCGs.

    <br><br>

    Using <tt>seq//1</tt>, we can define <tt>seqq//1</tt> to describe
    a sequence of sequences:

    <div>
      <pre class="box">
seqq([]) --&gt; [].
seqq([Es|Ess]) --&gt;
        seq(Es),
        seqq(Ess).</pre>
    </div>

    Sample use:

    <pre>
?- phrase(seqq(["ab","cd","ef"]), Ls).
<b>   Ls = "abcdef".</b>
    </pre>

    This is an elegant way to describe the <i>concatenation</i> of
    arbitrarily many lists.

    <br><br>

    It is sometimes useful to describe "any sequence at all", and we can
    do this with the nonterminal&nbsp;<tt>...&nbsp;//0</tt> which is
    equivalent to <tt>seq(_)</tt>:

    <div>
      <pre class="box">... --&gt; [] | [_], ... .</pre>
    </div>

    The grammar construct <tt>('|')//2</tt> and its
    equivalent&nbsp;<tt>(;)//2</tt> correspond to the Prolog control
    structure&nbsp;<tt>(;)/2</tt> and are read as "or". When parsing
    with DCGs, using <tt>('|')/2</tt> is preferable over <tt>(;)//2</tt>
    due to existing conventions for writing grammars.

    <br><br>

    <tt>seq//1</tt>, <tt>seqq//1</tt> and <tt>...&nbsp;//0</tt> are very
    versatile nonterminals and can be used to elegantly solve many
    tasks that involve reasoning over lists. For example, the last
    element of a list can be described with:

    <pre>
?- phrase((...,[Last]), "hello").
<b>   Last = o</b>
;  false.
    </pre>

    As another example, consecutively repeated elements in a list can be described with:

    <pre>
?- phrase((...,[E,E],...), Ls).
<b>   Ls = [E,E]
;  Ls = [E,E,_A]
;  Ls = [E,E,_A,_B]
;  Ls = [E,E,_A,_B,_C]
;  ... .</b>
    </pre>

    Using iterative deepening, we obtain a <i>fair</i> enumeration of answers:

    <pre>
?- length(Ls, _), phrase((...,[E,E],...), Ls).
<b>   Ls = [E,E]
;  Ls = [E,E,_A]
;  Ls = [_A,E,E]
;  Ls = [E,E,_A,_B]
;  Ls = [_A,E,E,_B]
;  Ls = [_A,_B,E,E]
;  ... .</b>
    </pre>


    In Scryer Prolog, <tt>seq//1</tt>, <tt>seqq//1</tt>
    and <tt>...&nbsp;//0</tt> are provided
    by <a href="https://github.com/mthom/scryer-prolog/blob/master/src/lib/dcgs.pl"><tt>library(dcgs)</tt></a>.
    </div>

    <center><h2>リストの反転、回文、その他の練習問題</h2></center>

    リストについて推論する場合や、リストを扱う問題を解く際に、
    DCGを使用すると便利です。

    <br><br>
    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="videos/dragon_curve"><img src="videos/t_dragon_curve.png" alt="Dragon Curve"></a></td>
      </tr>
    </table>

    <br><br>

    例えば、リストの<i>反転</i>は以下のように記述できます:

    <pre>
reversal([]) --&gt; [].
reversal([L|Ls]) --&gt; reversal(Ls), [L].
    </pre>

    クエリの例とその回答:

    <pre>
?- phrase(reversal("abcd"), Ls).
<b>   Ls = "dcba".</b>
    </pre>

    もう一つの例として、<i>回文</i>を以下のように記述できます:

    <pre>
palindrome --&gt; [].
palindrome --&gt; [_].
palindrome --&gt; [E], palindrome, [E].
    </pre>

    この定義は、回文を<i>生成</i>、<i>補完</i>、<i>検証</i>するために
    使用できます。
    例:

    <pre>
?- phrase(palindrome, "hellolleh").
<b>   true</b>
;  false.


?- phrase(palindrome, Ls).
<b>   Ls = []
;  Ls = [_A]
;  Ls = [_A,_A]
;  Ls = [_A,_B,_A]
;  Ls = [_A,_B,_B,_A]
;  ... .</b>
    </pre>

    <b>チャレンジ</b>:
    <tt>reversal//1</tt>を使用して
    <tt>palindrome//0</tt>を定義しなさい。
    2つの異なる定義を示してください。

    <br><br>
    <button onclick="toggleOriginalContent('原文_list')">原文</button>
    <div id="原文_list" class="hide_on_start">
    <center><h2>List reversal, palindromes and other exercises</h2></center>

    When reasoning about lists or solving exercises involving lists,
    consider using DCGs for convenience.

    <br><br>

    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/dragon_curve"><img src="videos/t_dragon_curve.png" alt="Dragon Curve"></a>
        </td>
      </tr>
    </table>

    <br><br>

    For example, the <i>reversal</i> of a list can be described with:

    <pre>
reversal([]) --&gt; [].
reversal([L|Ls]) --&gt; reversal(Ls), [L].
    </pre>

    Sample query and answer:

    <pre>
?- phrase(reversal("abcd"), Ls).
<b>   Ls = "dcba".</b>
    </pre>

    As another example, a <i>palindrome</i> can be described with:

    <pre>
palindrome --&gt; [].
palindrome --&gt; [_].
palindrome --&gt; [E], palindrome, [E].
    </pre>

    This definition can be used to <i>generate</i>, to <i>complete</i>
    and to <i>check</i> palindromes. For example:

    <pre>
?- phrase(palindrome, "hellolleh").
<b>   true</b>
;  false.


?- phrase(palindrome, Ls).
<b>   Ls = []
;  Ls = [_A]
;  Ls = [_A,_A]
;  Ls = [_A,_B,_A]
;  Ls = [_A,_B,_B,_A]
;  ... .</b>
    </pre>

    <b>Challenge</b>: Define <tt>palindrome//0</tt>
    using <tt>reversal//1</tt>. Provide two different definitions.
    </div>

    <center><h2>ツリーとリストの関連付け</h2></center>

    DCGを使用して、二分木とそのノード名の
    中置順序シーケンスとの関連付けを行いましょう。
    二分木は、葉がアトム <tt>nil</tt> で表され、
    内部ノードが <tt>node(Name, Left, Right)</tt> の形で
    構成されているとします。
    ここで、<tt>Left</tt> と <tt>Right</tt> はそれぞれ二分木です。
    ノード名の中置順序シーケンスを取得するには、次のように考えます:

    <pre>
tree_nodes(nil) --&gt; [].
tree_nodes(node(Name, Left, Right)) --&gt;
        tree_nodes(Left),
        [Name],
        tree_nodes(Right).
    </pre>

    使用例:

    <pre>
?- phrase(tree_nodes(node(a, node(b, nil,
                                     node(c, nil, nil)),
                             node(d, nil, nil))), Ns).
   <b>Ns = "bcad".</b>
    </pre>

    中置順序を取得するためには、DCG本体内で
    ターミナル <tt>[Name]</tt> の位置を移動することで、
    他の順序を取得することができます。

    <br><br>
    <button onclick="toggleOriginalContent('原文_tree')">原文</button>
    <div id="原文_tree" class="hide_on_start">
    <center><h2>Relating trees to lists</h2></center>

    Let us now use a DCG to relate a binary tree to the in-order
    sequence of its node names. Let us assume a binary tree consists
    of leaves represented by the atom&nbsp;<tt>nil</tt> and inner
    nodes of the form&nbsp;<tt>node(Name, Left, Right)</tt>,
    where <tt>Left</tt> and&nbsp;<tt>Right</tt> are themselves binary
    trees. To obtain the in-order sequence of node names, consider:

    <pre>
tree_nodes(nil) --&gt; [].
tree_nodes(node(Name, Left, Right)) --&gt;
        tree_nodes(Left),
        [Name],
        tree_nodes(Right).
    </pre>

    Example:

    <pre>
?- phrase(tree_nodes(node(a, node(b, nil,
                                     node(c, nil, nil)),
                             node(d, nil, nil))), Ns).
   <b>Ns = "bcad".</b>
    </pre>

    You can obtain other orders by moving the
    terminal&nbsp;<tt>[Name]</tt> in the DCG body.
    </div>
    
    <center><h2 id="leftrecursion">左再帰</h2></center>

    逆に、ノード名のシーケンスが与えられたときに、
    どのツリーがこのシーケンスを生成するかを考えてみましょう:

    <pre>
?- phrase(tree_nodes(Tree), "abcd").
<b>   Tree = node(a,nil,node(b,nil,node(c,nil,node(d,nil,nil))))</b>
;  % <i>(nontermination)</i>
    </pre>

    このシステムは1つの（正しい）解を返し、その後ループします。
    これは、文法が左再帰的であるためです：
    最初に他の何もせずに非終端記号（<tt>tree_nodes//1</tt>）を
    再帰的に参照しています。
    この文法を使用してすべての一致するツリーを見つけるには、
    2つ目のルールが適用されるためには、リストに少なくとも
    1つの要素が必要であり、そのチェックを事前に行って
    無限再帰を避ける必要があります。
    これを行うには、2つの追加引数を導入して、
    ルールの適用回数を指定されたリストの長さに制限します:

    <pre>
tree_nodes(nil, Ls, Ls) --&gt; [].
tree_nodes(node(Name, Left, Right), [_|Ls0], Ls) --&gt;
        tree_nodes(Left, Ls0, Ls1),
        [Name],
        tree_nodes(Right, Ls1, Ls).
    </pre>

    各追加引数のペアは、いわゆる
    <b>リストの差分</b>（<b>list&nbsp;difference</b>） を説明します。
    この方法と関連する用語を理解するには、例えば
    ペア <tt>Ls0</tt> と <tt>Ls1</tt> を考えてみましょう。
    これらのリストの <i>差分</i> は、この例では
    最初の再帰的呼び出しで消費されるリストの要素を説明していると
    解釈できます。
    同様に、リスト <tt>Ls1</tt> と <tt>Ls</tt> の <i>差分</i> は、
    2回目の呼び出しで消費されるリストの要素を示します。
    そして、ヘッドで発生するリストの <i>差分</i>、
    すなわち <tt>[_|Ls0]</tt> と <tt>Ls</tt> の差分は、
    2番目のルール全体で消費されるリストの要素を示しています。

    <br><br>
    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="videos/list_differences"><img src="videos/t_list_differences.png" alt="リストの差分"></a> </td>
      </tr>
    </table>

    <br><br>

    もちろん、ここでの <i>差分</i> は、算術的な意味ではなく
    <i>シンボリック</i> な意味で理解されるべきです。
    例えば、リスト <tt>[A,B,C]</tt> と <tt>[C]</tt> の
    <i>差分</i> は <tt>[A,B]</tt> であり、
    リスト <tt>[X,Y|Ls]</tt> と <tt>Ls</tt> の
    <i>差分</i> は <tt>[X,Y]</tt> であり、
    リスト <tt>Ls</tt> と <tt>Ls</tt> の
    <i>差分</i> は <tt>[]</tt> です。
    このような <i>リストの差分</i> を引数ペアを使って考えることで、
    リスト全体をサブリストについて考えることができます。
    この強力な方法は、実際には DCG を Prolog の述語に変換する
    一般的な <a href="#implementation">変換</a> の
    基礎となっています。
    これを使用している場合は、DCG を <i>代わりに</i> 使用することを
    考えてください。
    現在のケースでは、DCG の内部で <i>リストの差分</i> を
    明示的に使用しています。

    <br><br>

    文献では、<i>"差分リスト"</i>（<i>difference&nbsp;list</i>） という
    用語も見かけるでしょう。
    しかし、この用語は誤解を招く可能性があります：
    これは、名前が示唆するような
    特別な <i>種類</i> のリストを指しているわけではありません。
    追加の引数は、完全に普通の <a href="data#list">リスト</a> または
    部分リストです。重要なのは、それらの <i>差分</i> です。

    <br><br>

    リストの差分を扱う際には、各ペアを
    <i>単一の</i> 引数として渡したくなるかもしれません。
    例えば、<tt>Ls0-Ls1</tt> や <tt>Ls0/Ls1</tt> のように。
    しかし、これは推奨されません。
    主な理由は、他の述語や DCG の展開と衝突する可能性が高く、
    さらに、これらの複合タームを構築、分解、管理するための
    パフォーマンスオーバーヘッドが発生するためです。

    <br><br>

    使用例:

    <pre>
?- Ns = "abcd", phrase(tree_nodes(Tree, Ns, _), Ns).
<b>   Ns = "abcd", Tree = node(a,nil,node(b,nil,node(c,nil,node(d,nil,nil))))
;  Ns = "abcd", Tree = node(a,nil,node(b,nil,node(d,node(c,nil,nil),nil)))
;  Ns = "abcd", Tree = node(a,nil,node(c,node(b,nil,nil),node(d,nil,nil)))
;  ... .</b>
    </pre>

    左再帰的な文法で解析するもう一つのオプションは、
    Prolog システムの <a href="memoization#tabling">テーブル化</a>
    機能を使用することです。
    テーブル化と DCG を組み合わせると、 <i>パックラット解析</i> が実現します。
    このトピックについての興味深い論文は、Ralph Becket と Zoltan Somogyi による
    <a href="https://mercurylang.org/documentation/papers/packrat.pdf"><i>DCGs + Memoing = Packrat Parsing, But is it worth it?</i></a>
    です。

    <br><br>
    <button onclick="toggleOriginalContent('原文_left_recursion')">原文</button>
    <div id="原文_left_recursion" class="hide_on_start">
    <center><h2 id="leftrecursion">Left recursion</h2></center>

    Conversely, given a sequence of node names, what are the trees
    that yield this sequence:

    <pre>
?- phrase(tree_nodes(Tree), "abcd").
<b>   Tree = node(a,nil,node(b,nil,node(c,nil,node(d,nil,nil))))</b>
;  % <i>(nontermination)</i>
    </pre>

    The system yields one (correct) solution, then loops. This is
    because the grammar is left-recursive: We recursively refer to a
    nonterminal (<tt>tree_nodes//1</tt>) before anything else. To be
    able to use this grammar for finding all matching trees, we need
    to encode that for the second rule to apply, at least one list
    element must be available since the rule contains exactly one
    terminal, and we need to check this in advance to avoid unbounded
    recursion. We can do this by introducing two additional arguments
    that let us limit the number of rule applications to the given
    list's length:

    <pre>
tree_nodes(nil, Ls, Ls) --&gt; [].
tree_nodes(node(Name, Left, Right), [_|Ls0], Ls) --&gt;
        tree_nodes(Left, Ls0, Ls1),
        [Name],
        tree_nodes(Right, Ls1, Ls).
    </pre>

    Each respective pair of additional arguments describes a
    so-called <b>list&nbsp;difference</b>. To understand this method
    and its associated terminology, consider for example the
    pair <tt>Ls0</tt> and&nbsp;<tt>Ls1</tt>. We can interpret
    the <i>difference</i> of these lists as describing the list of
    elements that are consumed by the first recursive invocation
    of <tt>tree_nodes//3</tt> in this example. Analogously, the
    <i>difference</i> of the lists <tt>Ls1</tt> and <tt>Ls</tt> is the
    list of elements consumed by the second invocation. And the
    <i>difference</i> between the lists that occur in the head, i.e.,
    that of <tt>[_|Ls0]</tt> and <tt>Ls</tt>, describes the list of
    elements that are consumed by the entire second&nbsp;rule.

    <br><br>
    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/list_differences"><img src="videos/t_list_differences.png" alt="List differences"></a>
        </td>
      </tr>
    </table>

    <br><br>

    Of course, <i>difference</i> is to be understood in
    a <i>symbolic</i> sense in these cases, not in an arithmetic
    sense. For example, the <i>difference</i> between the
    lists <tt>[A,B,C]</tt> and&nbsp;<tt>[C]</tt>
    is&nbsp;<tt>[A,B]</tt>, the difference between <tt>[X,Y|Ls]</tt>
    and&nbsp;<tt>Ls</tt> is&nbsp;<tt>[X,Y]</tt>, and the difference
    between <tt>Ls</tt> and <tt>Ls</tt> is&nbsp;<tt>[]</tt>. By
    reasoning about such <i>list&nbsp;differences</i> via argument
    pairs, we can compose and decompose entire lists by reasoning
    about their sublists. This powerful method is in fact also the
    key&nbsp;idea that underlies the
    common <a href="#implementation">transformation</a> of DCGs to
    Prolog&nbsp;predicates. In cases where you are using it, consider
    using DCGs <i>instead</i>. In the present case, we are using list
    differences explicitly because we are using
    them <i>within</i>&nbsp;DCGs.

    <br><br>

    In the literature, you will also encounter the
    term <i>"difference&nbsp;list"</i>. However, this terminology is
    misleading: We are <i>not</i> talking about&mdash;as the name may
    suggest&mdash;a special <i>kind</i> of list. The additional
    arguments are completely
    ordinary&nbsp;<a href="data#list">lists</a> or partial&nbsp;lists.
    It is their <i>differences</i> that matter especially in such
    cases.

    <br><br>

    When working with list&nbsp;differences, you may be tempted to
    pass around each pair as a <i>single</i> argument, for example as
    compound terms like <tt>Ls0-Ls1</tt> or <tt>Ls0/Ls1</tt>. However,
    this is not advisable, primarily because you will likely run into
    conflicts with other predicates and DCG&nbsp;expansions, and
    secondarily because it incurs performance overhead for
    constructing, decomposing and managing these compound&nbsp;terms.

    <br><br>

    Example query:

    <pre>
?- Ns = "abcd", phrase(tree_nodes(Tree, Ns, _), Ns).
<b>   Ns = "abcd", Tree = node(a,nil,node(b,nil,node(c,nil,node(d,nil,nil))))
;  Ns = "abcd", Tree = node(a,nil,node(b,nil,node(d,node(c,nil,nil),nil)))
;  Ns = "abcd", Tree = node(a,nil,node(c,node(b,nil,nil),node(d,nil,nil)))
;  ... .</b>
    </pre>

    Another option to parse with left-recursive grammars is to use
    your Prolog system's <a href="memoization#tabling">tabling</a>
    mechanism. Combining tabled execution with DCGs
    yields <i>packrat&nbsp;parsing</i>; an interesting paper about
    this topic
    is <a href="https://mercurylang.org/documentation/papers/packrat.pdf"><i>DCGs
    + Memoing = Packrat Parsing, But is it worth it?</i></a> by Ralph
    Becket and Zoltan Somogyi.
    </div>
    
    <center><h2 id="semicontext">セミコンテキスト表記法</h2></center>

    <b>セミコンテキスト表記法</b>
    （古い用語で、<i>プッシュバックリスト</i> や
    <i>右側コンテキスト</i> とも呼ばれます）を使用すると、
    <i>残り</i> の要素について記述できます。
    操作的には、解析中のリストに最初は存在しなかった
    リスト要素を挿入することができます。
    次のような DCG ルールは:

    <pre>
Head, <b>[T<sub>1</sub>,...,T<sub>n</sub>]</b> --&gt; Body.
    </pre>

    操作的には、リストを <tt>Body</tt> を使って解析し、その後
    残りのリストに <tt>T<sub>1</sub>, ..., T<sub>n</sub></tt> を
    先頭に追加する、という意味になります。例えば:

    <pre>
nt1, <b>[b]</b> --&gt; [a].
nt2      --&gt; [b].
    </pre>

    <tt>nt1//0</tt> のボディは、単一の要素が atom <tt>a</tt> である
    リストを記述しています。
    操作的には、<tt>nt1//0</tt> が解析中のリストで
    atom <tt>a</tt> を消費した後、残りのリストの先頭に
    atom <tt>b</tt> を挿入します。
    <tt>nt2//0</tt> は、単一の要素が atom <tt>b</tt> である
    リストを記述しています。
    したがって、以下のクエリは成功します。
    なぜなら、<tt>nt2//0</tt> が atom <tt>b</tt> を消費し、
    それが <tt>nt1//0</tt> の成功後に残るリストに存在するからです:

    <pre>
?- phrase((nt1,nt2), "a").
<b>   true.</b>
    </pre>

    また、<tt>nt1//0</tt> を単独で使用することもできます。
    しかし、以下のクエリは <i>失敗</i> します。
    なぜなら、<tt>phrase/2</tt> は
    すべてのリスト要素が与えられた DCG ボディによって
    消費されるときのみ成功するからです:

    <pre>
?- phrase(nt1, "a").
<b>   false.</b>
    </pre>

    リスト差分バージョンの <tt>phrase/3</tt> は、
    <tt>nt1//0</tt> が成功した後に残る要素を示します:

    <pre>
?- phrase(nt1, "a", Rest).
<b>   Rest = "b".</b>
    </pre>

    予想通り、atom <tt>b</tt> がリストに残ります。

    <br><br>

    セミコンテキスト表記法を使用すると、<i>先読み</i> を実装できます。
    これは、次のリスト要素を取り除くことなく調べることができます。
    操作的には、まずそれを取り除き、その後プッシュバックします:

    <pre>
look_ahead(T), [T] --&gt; [T].
    </pre>

    例:

    <pre>
?- phrase(look_ahead(T), "a", Rest).
<b>   Rest = "a", T = a.</b>
    </pre>

    <br><br>
    <button onclick="toggleOriginalContent('原文_semicontext')">原文</button>
    <div id="原文_semicontext" class="hide_on_start">
    <center><h2 id="semicontext">Semicontext notation</h2></center>

    Using <b>semicontext notation</b>, in now outdated terminology
    also called <i>pushback lists</i> or <i>right-hand context</i>, we
    can make statements about <i>remaining</i> elements. Operationally
    speaking, we can insert list elements that were initially not in
    the list that is being parsed. A DCG rule of the form:

    <pre>
Head, <b>[T<sub>1</sub>,...,T<sub>n</sub>]</b> --&gt; Body.
    </pre>

    can be read operationally as: parse the list
    using&nbsp;<tt>Body</tt>, then prepend the
    terms&nbsp;<tt>T<sub>1</sub>,&nbsp;...,&nbsp;T<sub>n</sub></tt> to the remaining list.
    For example:

    <pre>
nt1, <b>[b]</b> --&gt; [a].
nt2      --&gt; [b].
    </pre>

    The body of <tt>nt1//0</tt> describes a list whose single element
    is the atom&nbsp;<tt>a</tt>. Operationally, after <tt>nt1//0</tt>
    has consumed the atom&nbsp;<tt>a</tt> in a list that is being
    parsed, it inserts the atom&nbsp;<tt>b</tt> in front of the
    remaining list. <tt>nt2//0</tt> describes a list whose single
    element is the atom&nbsp;<tt>b</tt>. The following query therefore
    succeeds, since <tt>nt2//0</tt> consumes the atom&nbsp;<tt>b</tt>,
    which is left in the list after <tt>nt1//0</tt> succeeds:

    <pre>
?- phrase((nt1,nt2), "a").
<b>   true.</b>
    </pre>

    We can also use <tt>nt1//0</tt> in isolation. However, the following query
    <i>fails</i> since <tt>phrase/2</tt> only succeeds if all list elements
    are consumed by the given DCG body:

    <pre>
?- phrase(nt1, "a").
<b>   false.</b>
    </pre>

    The list difference version <tt>phrase/3</tt> shows what remains
    after <tt>nt1//0</tt> succeeds:

    <pre>
?- phrase(nt1, "a", Rest).
<b>   Rest = "b".</b>
    </pre>

    As expected, the atom&nbsp;<tt>b</tt> remains in the list.

    <br><br>

    Using semicontext notation, we can implement <i>look ahead</i>,
    which lets us inspect the next element in the list without
    removing it. Operationally, we first remove it and then push it
    back:

    <pre>
look_ahead(T), [T] --&gt; [T].
    </pre>

    Example:

    <pre>
?- phrase(look_ahead(T), "a", Rest).
<b>   Rest = "a", T = a.</b>
    </pre>
    </div>
    
    <center><h2>状態を暗黙的に渡す</h2></center>

    <a href="#semicontext">セミコンテキスト表記法</a>は、
    状態表現を暗黙的に渡すためにも便利です。
    これは、状態が特定のルールのサブセットによってのみアクセスされ、
    変更される場合に役立ちます。
    例えば、バイナリツリーの葉の数を数える場合を考えてみましょう。
    DCGを使用せずに、ツリーをその葉の数に関連付ける方法は次の通りです:

    <pre>
num_leaves(Tree, N) :-
        num_leaves_(Tree, 0, N).

num_leaves_(nil, N0, N) :- N #= N0 + 1.
num_leaves_(node(_,Left,Right), N0, N) :-
        num_leaves_(Left, N0, N1),
        num_leaves_(Right, N1, N).
    </pre>

    ここで、<tt>num_leaves_/3</tt> の第二の節では、アキュムレーターが
    <tt>N0</tt>、<tt>N1</tt>、<tt>...</tt>、<tt>N</tt> として渡され、
    直接変更されることはありません。
    このようなパターンに遭遇した場合は、DCG表記法を使用して
    引数を<i>暗黙的に</i>渡すことを検討してみてください。

    この具体的なケースでは、渡す状態は
    これまでに遭遇した葉の数を示す単一の整数です。
    状態をインクリメントするために、上記のように Prolog の
    <a href="/prolog/clpfd"><b>宣言型整数算術</b></a> を使用します。
    Prologの述語をDCGボディ内から呼び出すには、
    DCG言語構造 <tt>{}//1</tt> を使用します。
    操作的には、DCGボディ内で <tt>{Goal}</tt> に遭遇すると、
    <tt>Goal</tt> が Prolog の目標として呼び出されます。
    DCG は常にリストを記述する必要があるため、
    状態をリストにラップし、単一の要素を含むリストを記述します。
    初期状態は再び 0 として指定され、
    葉の数は <tt>num_leaves_//1</tt> が成功した後の残りのリスト要素で示されます:

    <pre>
num_leaves(Tree, N) :-
        phrase(num_leaves_(Tree), [0], [N]).

num_leaves_(nil), [N] --&gt; [N0], { N #= N0 + 1 }.
num_leaves_(node(_,Left,Right)) --&gt;
        num_leaves_(Left),
        num_leaves_(Right).
    </pre>

    ここで、<tt>num_leaves_//1</tt> の第二のルールは
    状態には全く言及していません。
    なぜなら、内部ノードを処理するときに葉の数が変更されないからです。

    <br><br>

    例:

    <pre>
?- num_leaves(node(a,node(b,nil,nil),
                     node(c,nil,
                            node(d,nil,nil))), N).
<b>N = 5.</b>
    </pre>

    DCGで状態を記述する際に役立つ非終端記号は以下の通りです:

    <div id="state">
      <pre class="box">
state(S), [S] --&gt; [S].

state(S0, S), [S] --&gt; [S0].</pre>
    </div>

    <b>注:</b>
    グレーのボックス内のコードは、
    あなたのプロジェクトで再利用するのに役立つかもしれません。

    <br><br>

    非終端記号 <tt>state(S)</tt> は、
    「現在の状態は <tt>S</tt> である」と読み取れます。
    非終端記号 <tt>state(S0, S)</tt> は、
    「現在の状態は <tt>S0</tt> であり、
    それ以降は <tt>S</tt> である」と読み取れます。

    <br><br>

    <tt>state//2</tt> を使用すると、
    <tt>num_leaves_//1</tt> を次のように書き換えることができます:

    <pre>
num_leaves_(nil) --&gt; state(N0, N), { N #= N0 + 1 }.
num_leaves_(node(_,Left,Right)) --&gt;
        num_leaves_(Left),
        num_leaves_(Right).
    </pre>

    このアプローチは、複数の状態を通じて
    スレッド処理する場合にも容易に一般化できます。
    例えば、このようなケースでは
    <tt>s(S1,S2,...,Sn)</tt> のような項を使用することができます。

    <br><br>
    <button onclick="toggleOriginalContent('原文_passing_states')">原文</button>
    <div id="原文_passing_states" class="hide_on_start">
    <center><h2>Implicitly passing states around</h2></center>

    <a href="#semicontext">Semicontext notation</a> is also useful to
    implicitly pass around a state representation that is only
    accessed and changed by a subset of rules. For example, let us
    count the leaves in a binary tree with the above
    presentation. Without using DCGs, we can relate a tree to the
    number of its leaves as follows:

    <pre>
num_leaves(Tree, N) :-
        num_leaves_(Tree, 0, N).

num_leaves_(nil, N0, N) :- N #= N0 + 1.
num_leaves_(node(_,Left,Right), N0, N) :-
        num_leaves_(Left, N0, N1),
        num_leaves_(Right, N1, N).
    </pre>

    Notice that in the second clause of <tt>num_leaves_/3</tt>, the
    accumulator is only passed through
    as <tt>N0</tt>, <tt>N1</tt>, <tt>...</tt>, <tt>N</tt> and not
    modified directly. When you encounter such a pattern, consider
    using DCG notation to pass around the arguments <i>implicitly</i>.

    In this concrete case, the <i>state</i> we shall pass around is a
    single integer denoting the number of leaves encountered so far.
    To increment the state, we use
    Prolog's <a href="/prolog/clpfd"><b>declarative integer
    arithmetic</b></a> like above. To invoke a Prolog predicate from
    within a DCG body, we use the DCG language
    construct&nbsp;<tt>{}//1</tt>. Operationally, when the
    construct&nbsp;<tt>{Goal}</tt> is encountered in a DCG
    body,&nbsp;<tt>Goal</tt> is called as a Prolog goal. Since
    a&nbsp;DCG must always describe a list, we wrap the state into a
    list and thus describe a list containing a single element. The
    initial state is again sensibly specified as&nbsp;0, and the
    number of leaves is given by the remaining list element
    after <tt>num_leaves_//1</tt> succeeds:

    <pre>
num_leaves(Tree, N) :-
        phrase(num_leaves_(Tree), [0], [N]).

num_leaves_(nil), [N] --&gt; [N0], { N #= N0 + 1 }.
num_leaves_(node(_,Left,Right)) --&gt;
        num_leaves_(Left),
        num_leaves_(Right).
    </pre>

    Notice that the second rule of <tt>num_leaves_//1</tt> makes no
    reference at all to the state, since the number of leaves is not
    modified when an inner node is processed.

    <br><br>
    Example query:

    <pre>
?- num_leaves(node(a,node(b,nil,nil),
                     node(c,nil,
                            node(d,nil,nil))), N).
<b>N = 5.</b>
    </pre>

    The following nonterminals are useful for describing states with
    DCGs:

    <div id="state">
      <pre class="box">
state(S), [S] --&gt; [S].

state(S0, S), [S] --&gt; [S0].</pre>
    </div>

    <b>Note</b>: Code in grey boxes may be useful for you to reuse in
    your own projects.
    <br><br>

    The nonterminal <tt>state(S)</tt> can be read as: "The current
    state is <tt>S</tt>". The nonterminal <tt>state(S0, S)</tt> can be
    read as: "The current state is <tt>S0</tt>, and henceforth it
    is <tt>S</tt>".

    <br><br>

    Using <tt>state//2</tt>, you can write <tt>num_leaves_//1</tt> as:

    <pre>
num_leaves_(nil) --&gt; state(N0, N), { N #= N0 + 1 }.
num_leaves_(node(_,Left,Right)) --&gt;
        num_leaves_(Left),
        num_leaves_(Right).
    </pre>

    This approach is readily generalized to multiple states that are
    threaded through: You can for example use a
    term&nbsp;<tt>s(S1,S2,...,Sn)</tt> in such cases.
    </div>

    <center><h2>ファイルからの読み込み</h2></center>

    Scryer Prolog、SICStus Prolog、SWI-Prologでは、
    ウルリッヒ・ノイメルケルの
    <a href="http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/sicstus/pio.pl"><b><tt>library(pio)</tt></b></a>
    を使用して、DCGをファイルに適用することができます。
    ファイルからの入力を処理する必要がある場合、
    まず入力を記述するDCGを作成します。
    これにより、<tt>phrase/2</tt>を使用してDCGを純粋にテストでき、
    ファイルに対しては<tt>phrase/2</tt>の代わりに
    <tt>phrase_from_file/2</tt>を使用するだけでDCGを適用できます。

    <br><br>
    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="videos/reading_from_files"><img src="videos/t_reading_from_files.png" alt="ファイルからの読み込み"></a>
        </td>
      </tr>
    </table>

    <br><br>

    最初の例では、ファイル全体を<i>文字のリスト</i>として読み込みます。
    これは、上で定義した<tt>seq//1</tt>を使用すると非常に簡単にできます。
    例えば、ファイル<tt>dcg.html</tt>の内容を文字のリストに読み込むには、
    次のようにします:

    <pre>
?- phrase_from_file(seq(Chars), "dcg.html").
<b>   Chars = "&lt;!DOCTYPE html&gt;\n&lt;ht ..."</b>
;  false.
    </pre>

    次の例では、<tt>seq//1</tt>を使用して文字の部分列を参照するDCGを考えます:

    <pre>
like(What) --&gt; "I like ", seq(What), ".", ... .
    </pre>

    前述のように、このDCGを使って与えられた文字のリストを解析できます:

    <pre>
?- phrase(like(What), "I like it. Anything can follow!").
<b>   What = "it"</b>
;  false.
    </pre>

    期待通り、<tt>What</tt>は文字<tt>i</tt>と<tt>t</tt>と一致します。

    <br><br>

    さらに、<tt>library(pio</tt>と<tt>phrase_from_file/2</tt>を使用して、
    同じDCGでファイルから解析を行うこともできます。
    ファイル<tt>like.txt</tt>の最初の文字列が「I like it.」であると仮定します。

    <pre>
?- phrase_from_file(like(What), "like.txt").
<b>   What = "it"</b>
;  false.
    </pre>

    この場合も、<tt>What</tt>は<tt>i</tt>と<tt>t</tt>と一致します。

    <br><br>

    <tt>library(pio)</tt>による純粋な入力は、
    ファイルの解析時にメモリ効率が良い方法で実装できます。
    まず、ファイルは<i>遅延読み込み</i>で処理され、必要な分だけが読み込まれます。
    次に、Prologシステムが文字のリストを効率的に表現できる場合、
    ファイルの内容は非常にコンパクトにメモリ上に表現できます。
    さらに、解析に不要になったファイルの内容は、Prologシステムが
    <a href="https://www.complang.tuwien.ac.at/ulrich/papers/PDF/2008-ciclops.pdf"><i>Prologにおける正確なガベージコレクション</i></a>
    で概説された特性を満たしている場合、自動的に解放されます。

    <br><br>

    これらの理由により、<tt>library(pio)</tt>は
    大規模なファイルを解析する場合にも適しています。

    <br><br>
    <button onclick="toggleOriginalContent('原文_reading_from_files')">原文</button>
    <div id="原文_reading_from_files" class="hide_on_start">
    <center><h2>Reading from files</h2></center>

    In Scryer Prolog, SICStus Prolog and SWI-Prolog, DCGs can be
    transparently applied to files using Ulrich
    Neumerkel's <a href="http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/sicstus/pio.pl"><b><tt>library(pio)</tt></b></a>.
    When you need to process input from files, first write a DCG that
    describes the input. This lets you test the DCG in a pure way
    using&nbsp;<tt>phrase/2</tt>, and then apply the DCG to files too
    by simply using <tt>phrase_from_file/2</tt> instead
    of <tt>phrase/2</tt>.

    <br><br>
    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/reading_from_files"><img src="videos/t_reading_from_files.png" alt="Reading from Files"></a>
        </td>
      </tr>
    </table>


    <br><br>

    In our first example, we read a whole file to a <i>list of
    characters</i>. This is very easy to do with <tt>seq//1</tt> as
    defined above. For example, to read the contents of the
    file <tt>dcg.html</tt> to a list of characters, we use:

    <pre>
?- phrase_from_file(seq(Chars), "dcg.html").
<b>   Chars = "&lt;!DOCTYPE html&gt;\n&lt;ht ..."</b>
;  false.
    </pre>

    As another example, consider the following DCG that
    uses <tt>seq//1</tt> to refer to a subsequence of characters:

    <pre>
like(What) --&gt; "I like ", seq(What), ".", ... .
    </pre>

    As before, we can use this DCG to parse a given list of characters:

    <pre>
?- phrase(like(What), "I like it. Anything can follow!").
<b>   What = "it"</b>
;  false.
    </pre>

    As expected, <tt>What</tt> is unified with the atoms&nbsp;<tt>i</tt>
    and&nbsp;<tt>t</tt>.

    <br><br>

    Moreover, using <tt>library(pio)</tt> and
    its <tt>phrase_from_file/2</tt>, we can transparently parse from a
    file with the same DCG. Assume that the
    file&nbsp;<tt>like.txt</tt> starts with the string "I like it."

    <pre>
?- phrase_from_file(like(What), "like.txt").
<b>   What = "it"</b>
;  false.
    </pre>

    Again, <tt>What</tt> is unified with the atoms&nbsp;<tt>i</tt>
    and&nbsp;<tt>t</tt>.

    <br><br>

    Pure input via <tt>library(pio)</tt> can be implemented in such a
    way that it uses memory efficiently when parsing files: First, the
    file can be read <i>lazily</i>, reading only as much as is needed.
    Second, file contents can be very compactly represented in memory
    if your Prolog system supports an
    <a href="data#string">efficient representation</a> of lists of
    characters. Third, file contents that are no longer relevant for
    parsing can be reclaimed automatically if your Prolog system
    satisfies the properties outlined
    in <a href="https://www.complang.tuwien.ac.at/ulrich/papers/PDF/2008-ciclops.pdf"><i>Precise
    Garbage Collection in Prolog</i></a>.

    <br><br>

    For these reasons, <tt>library(pio)</tt> is well-suited
    also for parsing large files.
    </div>
    
    <center><h2>解析のトリックとテクニック</h2></center>

    解析時に、トークンを<i>貪欲に</i>消費したいことがよくあります。
    つまり、<i>最も長い</i>一致が優先されるべきです。
    これを実現するには、DCGのルールを適切に並べ替えます。
    たとえば、次のDCGは、空白文字のリストを最も長い一致が
    最初の解になるように記述しています。
    この例では、文字分類には
    <a href="https://github.com/mthom/scryer-prolog/blob/master/src/lib/charsio.pl"><tt>library(charsio)</tt></a>
    の<tt>char_type/2</tt>を使用します:

    <pre>
ws --&gt; [W], { char_type(W, whitespace) }, ws.
ws --&gt; [].
    </pre>

    識別子は、文字で始まり、文字または数字を含むことができる必要があります。
    このテクニックを応用すると、次のように解析できます:

    <pre>
identifier([A|As]) --&gt; [A], { char_type(A, alpha) }, symbol_r(As).

symbol_r([A|As]) --&gt; [A], { char_type(A, alnum) }, symbol_r(As).
symbol_r([])     --&gt; [].
    </pre>

    次に、解析に役立つことがある別のテクニックを紹介します。
    以下のDCGルールは、改行またはファイルの終端で終了する
    <i>行のリスト</i>を記述しています:

    <div>
      <pre class="box">
lines([])     --&gt; call(eos), !.
lines([L|Ls]) --&gt; line(L), lines(Ls).

line([])     --&gt; ( "\n" | call(eos) ), !.
line([C|Cs]) --&gt; [C], line(Cs).

eos([], []).</pre>
    </div>

    非終端記号<tt>call//1</tt>は、
    暗黙のDCG引数が明示的な引数として利用できるように、
    Prologの述語を呼び出すために使用されます。
    これは、文字列の終端条件を記述するために必要です。
    また、文法構造<tt>!//0</tt>は、対応するPrologの制御構造のように使用されます。

    <br><br>

    これらの定義を使用して、ファイルの内容を行のリストとして取得し、
    さらなる推論に利用できます:

    <pre>
?- phrase_from_file(lines(Ls), "like.txt").
<b>   Ls = ["I like it. Anythi ..."].</b>
    </pre>

    <b>注</b>: <tt>eos/2</tt>は比較的使用頻度が低いです。
    上記のケースでは、「新しい行の始まり」であることを示すために使用していますが、
    通常は、記述したいことをもっと直接的に表現できます。
    <tt>phrase/2</tt>や<tt>phrase_from_file/2</tt>は、
    <i>完全な</i>リストやファイルが記述と一致した場合にのみ成功するため、
    明示的に「文字列の終わり」に言及する必要は通常ありません。

    <br><br>
    <button onclick="toggleOriginalContent('原文_parsing_tricks_and_techniques')">原文</button>
    <div id="原文_parsing_tricks_and_techniques" class="hide_on_start">
    <center><h2>Parsing tricks and techniques</h2></center>

    When parsing, we often want to consume tokens <i>greedily</i>,
    meaning that the <i>longest</i> match should be given priority. We
    can do this by ordering the DCG&nbsp;rules accordingly. For
    example, the following DCG describes a list of whitespace
    characters in such a way that the longest such sequence is the
    first solution, using <tt>char_type/2</tt>
    from <a href="https://github.com/mthom/scryer-prolog/blob/master/src/lib/charsio.pl"><tt>library(charsio)</tt></a> for character classification:

    <pre>
ws --&gt; [W], { char_type(W, whitespace) }, ws.
ws --&gt; [].
    </pre>

    Identifiers that must start with a letter and may contain
    either letters or digits can be parsed by applying this technique:

    <pre>
identifier([A|As]) --&gt; [A], { char_type(A, alpha) }, symbol_r(As).

symbol_r([A|As]) --&gt; [A], { char_type(A, alnum) }, symbol_r(As).
symbol_r([])     --&gt; [].
    </pre>

    As another technique that is sometimes useful for parsing, here
    are DCG rules that describe a list of <i>lines</i> that are
    terminated by line feed or end of file:

    <div>
      <pre class="box">
lines([])     --&gt; call(eos), !.
lines([L|Ls]) --&gt; line(L), lines(Ls).

line([])     --&gt; ( "\n" | call(eos) ), !.
line([C|Cs]) --&gt; [C], line(Cs).

eos([], []).</pre>
    </div>

    The nonterminal <tt>call//1</tt> is used to call a Prolog
    predicate in such a way that the implicit DCG arguments are made
    available as explicit arguments. We need this to describe the
    condition "end of string". The grammar construct
    <tt>!//0</tt> is used like the corresponding Prolog control
    structure.

    <br><br>

    We can use these definitions to obtain the contents of a file as
    a list of lines for further reasoning:

    <pre>
?- phrase_from_file(lines(Ls), "like.txt").
<b>   Ls = ["I like it. Anythi ..."].</b>
    </pre>

    <b>Note</b>: <tt>eos/2</tt> is comparatively rarely needed. In the
    above case it is used because <i>anything else</i> is the
    beginning of a new line. Typically, you can more directly express
    what you want to describe, and <tt>phrase/2</tt>
    and <tt>phrase_from_file/2</tt> only succeed if
    the <i>complete</i> list or file matches the description.
    Therefore, it is typically not necessary to explicitly refer to
    "end of the string".
    </div>
    
    <center><h2 id="output">出力の記述</h2></center>

    DCGsは、<i>出力</i>を記述するのにも役立ちます。
    出力は文字のリストであるためです。
    Scryer Prologは、
    <a href="https://github.com/mthom/scryer-prolog/blob/master/src/lib/format.pl"><tt>library(format)</tt></a>
    を使って、指定された引数のレイアウトを定義する
    <i>フォーマット文字列</i>に基づいて、
    出力を宣言的に記述するための非終端記号<tt>format_//2</tt>を提供しています。

    <br><br>
    <table>
      <tr>
        <td><i>ビデオ</i>:</td> <td><a href="videos/formatting_output"><img src="videos/t_formatting_output.png" alt="出力のフォーマット"></a>
        </td>
      </tr>
    </table>
    <br><br>

    たとえば、<tt>format_//2</tt>を使って<i>テーブル</i>を記述できます:

    <pre>
table --&gt;
    row([this,is,a]),
    row([very,nice,table]).

row(Ls) --&gt; format_("~t~w~7+~t~w~7+~t~w~7+~n", Ls).
    </pre>


    次のようにクエリを実行し、その結果を得ることができます:

    <pre>
?- phrase(table, Ts).
<b>   Ts = "   this     is      ..."</b>.
    </pre>

    この宣言的な方法で出力を記述する大きな利点は、
    <i>テストケース</i>を作成し、論理的に推論できることです。
    システム端末にのみ表示される出力について推論するのは難しいですが、
    文字のリストについて保持すべき特性を記述するのは容易です。

    <br><br>

    必要に応じて、<tt>format/2</tt>を1回呼び出すだけで
    端末にテーブルを表示することも可能です:

    <pre>
?- phrase(table, Ts), format("~s", [Ts]).
<b>   this     is      a
   very   nice  table</b>
   Ts = "   this     is      ...".
    </pre>

    <br><br>
    <button onclick="toggleOriginalContent('原文_output')">原文</button>
    <div id="原文_output" class="hide_on_start">
    <center><h2 id="output">Describing output</h2></center>

    DCGs are also useful for describing <i>output</i>, because output
    is a list of characters.
    In <a href="https://github.com/mthom/scryer-prolog/blob/master/src/lib/format.pl"><tt>library(format)</tt></a>,
    Scryer Prolog provides the nonterminal <tt>format_//2</tt> to
    declaratively describe output based on a <i>format&nbsp;string</i>
    that defines the layout of specified arguments.

    <br><br>
    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/formatting_output"><img src="videos/t_formatting_output.png" alt="Formatting Output"></a>
        </td>
      </tr>
    </table>
    <br><br>

    For example, we can describe a <i>table</i> with <tt>format_//2</tt>:

    <pre>
table --&gt;
    row([this,is,a]),
    row([very,nice,table]).

row(Ls) --&gt; format_("~t~w~7+~t~w~7+~t~w~7+~n", Ls).
    </pre>

    Sample query and its results:

    <pre>
?- phrase(table, Ts).
<b>   Ts = "   this     is      ..."</b>.
    </pre>

    An important advantage of this declarative way to describe output
    is that we can write <i>test&nbsp;cases</i> and reason about it:
    It is quite hard to reason about output that only appears on the
    system terminal, with no other tangible manifestation. In
    contrast, it is easy to state properties that must hold about a
    list of characters.

    <br><br>

    When needed, we can show the table on the terminal with a single
    call of&nbsp;<tt>format/2</tt>:

    <pre>
?- phrase(table, Ts), format("~s", [Ts]).
<b>   this     is      a
   very   nice  table</b>
   Ts = "   this     is      ...".
    </pre>
    </div>
    
    <center><h2 id="implementation">実装</h2></center>

    Scryer PrologでDCG（文法記述）を内部的にどのように実装しているかを見るために、
    <tt>library(format)</tt>の<tt>listing/1</tt>を使用できます。
    たとえば、<tt>num_leaves_//1</tt>の実際のソースコードを確認するには、
    <tt>dynamic/1</tt>ディレクティブを使って非終端記号を動的に宣言し、次のようにします:

    <pre>
?- listing(num_leaves_//1).
<b>num_leaves_(nil,A,B) :-
   state(C,D,A,E),
   D#=C+1,
   E=B.
num_leaves_(node(A,B,C),D,E) :-
   num_leaves_(B,D,F),
   num_leaves_(C,F,E).</b>
    </pre>

    ここでは、<tt>num_leaves_//1</tt>の2つのDCGルールが、
    2つの追加引数を持つPrologルールに機械的に書き換えられたことがわかります。
    DCGのPrologコードへの変換は、他の言語における
    <a href="macros"><b>マクロ</b></a>に類似したメカニズムである
    <tt>term_expansion/2</tt>によって行われます。

    <br><br>

    移植性を考慮すると、特定の展開手法に依存しないほうがよいでしょう。
    代わりに、状態を参照する際にはセミコンテキスト表記を使用し、
    常に<tt>phrase/[2,3]</tt>インターフェースを使ってDCGを呼び出すようにしましょう。
    この方法では、Prologシステムが
    より効率的な展開方法を適用する自由を持つことができます。
    たとえば、最後の2つの引数を入れ替えることで、
    特定の仮想マシンの特性に基づいてより効率的な述語呼び出しが可能になるかもしれません。

    <br><br>
    <button onclick="toggleOriginalContent('原文_implementation')">原文</button>
    <div id="原文_implementation" class="hide_on_start">
    <center><h2 id="implementation">Implementation</h2></center>

    To see how DCGs are internally implemented in Scryer Prolog, we
    can use <tt>listing/1</tt> from <tt>library(format)</tt>. For
    example, to see the actual source code of <tt>num_leaves_//1</tt>,
    we declare the nonterminal dynamic via the <tt>dynamic/1</tt>
    directive, and use:

    <pre>
?- listing(num_leaves_//1).
<b>num_leaves_(nil,A,B) :-
   state(C,D,A,E),
   D#=C+1,
   E=B.
num_leaves_(node(A,B,C),D,E) :-
   num_leaves_(B,D,F),
   num_leaves_(C,F,E).</b>
    </pre>

    We see that internally, the two DCG rules
    of <tt>num_leaves_//1</tt> were translated into Prolog rules with
    two additional arguments, following mechanical rewriting steps.
    The translation of DCGs to Prolog code is done
    by <tt>term_expansion/2</tt>, a mechanism analogous
    to <a href="macros"><b>macros</b></a> in other languages.

    <br><br>

    For portability, it is best not to rely on a particular expansion
    method. Instead, use semicontext notation to refer to states and
    always use the <tt>phrase/[2,3]</tt> interface to invoke a DCG.
    This way, a Prolog system is free to apply a different expansion
    method that may be more efficient. For example, the last two
    arguments may as well be swapped and allow more efficient
    predicate calls this way due to specifics of a particular virtual
    machine.
    </div>

    <center><h2>DCGの使用</h2></center>

    次のような場合にDCG（文法記述器）を使用することを検討してください：
    <ul>
      <li>リストを記述しているとき</li>
      <li>ファイルから読み取るとき</li>
      <li>状態表現をやり取りし、その状態を実際に使用または変更する述語が限られているとき</li>
    </ul>

    本格的なPrologプログラムでは、上記のいずれかの理由により、
    DCGを使用する機会が多く見つかるでしょう。

    <br><br>

    次に、通常のProlog述語と同等のDCG非終端記号を並べて比較し、
    DCGの使用における重要な側面をいくつか思い出し、新たな観察をしてみましょう。
    よく知られているProlog述語<tt>include/3</tt>を例に取ります：

    <center>
      <table style="border: 1px dotted; margin-top: 1em; margin-bottom: 1em">
        <tr><td style="padding-top: 1em; padding-bottom: 1em; padding-right: 1em"><center><b>通常の Prolog</b></center></td>
          <td><center><b>Prolog DCG</b></center></td></tr>
        <tr>
          <td style="padding-right: 1em">
            <pre>
include(Goal, List, Included) :-
        include_(List, Goal, Included).

include_([], _, []).
include_([L|Ls], Goal, Included0) :-
        (   call(Goal, L) -&gt;
            Included0 = [L|Included]
        ;   Included0 = Included
        ),
        include_(Ls, Goal, Included).
            </pre>
          </td>
          <td style="padding-right: 1em">
            <pre>
include(Goal, List, Included) :-
        <b>phrase</b>(include_(List, Goal), Included).

include_([], _) --&gt; [].
include_([L|Ls], Goal) --&gt;
        (   { call(Goal, L) } -&gt;
            [L]
        ;   []
        ),
        include_(Ls, Goal).
            </pre>
          </td>
        </tr>
      </table>
    </center>


    両方のバージョンの使用例：

    <pre>
?- include(integer, [a,b,c,1,2,e], Is).
<b>Is = [1, 2]</b>.
    </pre>

    ここで特に注目すべき点は次の通りです：
    <ul>
      <li>DCG非終端記号を通常のProlog述語内で参照するには
        、<tt>phrase/2</tt>を使用する必要がある</li>
      <li>逆に、DCG内で通常のPrologゴールを呼び出すには、
        <tt>{}//1</tt>を使用する</li>
      <li>DCGバージョンは明示的な引数が少なく、読みやすく理解しやすい</li>
      <li>これは前述の点に強く関連していますが、
        DCGバージョンは参照する<i>変数</i>が少ないことも注目に値します</li>
      <li>DCGを使用することで、
        <i>リスト</i>が記述されていることがすぐに明確になる</li>
    </ul>

    どちらのバージョンが読みやすく理解しやすいか、じっくりと確認してみてください。

    <br><br>

    以下は、このサイトからダウンロードして学習できるDCGの応用例です：
    <ul>
      <li><a href="/misc/markov.pl">markov.pl</a>は、
        マルコフ連鎖の出力を記述するためにDCGを使用しています</li>
      <li><a href="/lisprolog/">Lisprolog</a>は、
        Lisp式を解析し、環境の状態を暗黙的に伝播させるためにDCGを使用しています</li>
      <li><a href="/tist/">Tist</a>は、
        文書全体にわたって上記のすべての理由でDCGを使用しています</li>
      <li><a href="/prolog/faq/">comp.lang.prolog FAQ</a>は
        DCGで記述されています。</li>
    </ul>

    <br><br>
    <button onclick="toggleOriginalContent('原文_using')">原文</button>
    <div id="原文_using" class="hide_on_start">
    <center><h2>Using DCGs</h2></center>

    Consider using DCGs if you are:
    <ul>
      <li>describing a list</li>
      <li>reading from a file</li>
      <li>passing around a state representation that only a few
        predicates actually use or modify.</li>
    </ul>

    In every serious Prolog program, you will find many opportunities to
    use DCGs due to some subset of the above reasons.

    <br><br>

    Let us study one side-by-side comparison of a regular Prolog
    predicate and an equivalent DCG nonterminal to recall several
    important aspects of using DCGs and make some additional
    observations. We take the well-known Prolog
    predicate <tt>include/3</tt> as an example:

    <center>
      <table style="border: 1px dotted; margin-top: 1em; margin-bottom: 1em">
        <tr><td style="padding-top: 1em; padding-bottom: 1em; padding-right: 1em"><center><b>regular Prolog</b></center></td>
          <td><center><b>Prolog DCG</b></center></td></tr>
        <tr>
          <td style="padding-right: 1em">
            <pre>
include(Goal, List, Included) :-
        include_(List, Goal, Included).

include_([], _, []).
include_([L|Ls], Goal, Included0) :-
        (   call(Goal, L) -&gt;
            Included0 = [L|Included]
        ;   Included0 = Included
        ),
        include_(Ls, Goal, Included).
            </pre>
          </td>
          <td style="padding-right: 1em">
            <pre>
include(Goal, List, Included) :-
        <b>phrase</b>(include_(List, Goal), Included).

include_([], _) --&gt; [].
include_([L|Ls], Goal) --&gt;
        (   { call(Goal, L) } -&gt;
            [L]
        ;   []
        ),
        include_(Ls, Goal).
            </pre>
          </td>
        </tr>
      </table>
    </center>

    Usage example for both versions:

    <pre>
?- include(integer, [a,b,c,1,2,e], Is).
<b>Is = [1, 2]</b>.
    </pre>

    We recall and note in particular:

    <ul>
      <li><tt>phrase/2</tt> must of course be used to refer to a DCG
        nonterminal within a regular Prolog predicate</li>
      <li>conversely, <tt>{}//1</tt> is used to call a regular Prolog goal within a DCG</li>
      <li>the DCG version needs fewer explicit arguments, making it slightly easier to read and understand</li>
      <li>although it is strongly related to the previous point, it is
        still worth mentioning explicitly that the DCG version also
        refers to fewer <i>variables</i></li>
      <li>using a DCG makes immediately clear that a <i>list</i> is
      being described.
    </ul>

    Take your time and see for yourself which of the two versions you
    find easier to read and understand.

    <br><br>
    
    Some applications of DCGs that you can download from this site and study:

    <ul>
      <li><a href="/misc/markov.pl">markov.pl</a> uses DCGs to
      describe output of a Markov chain</li>
      <li><a href="/lisprolog/">Lisprolog</a> uses DCGs to parse Lisp expressions and to implicitly thread through the state of the environment</li>
      <li><a href="/tist/">Tist</a> uses DCGs for all of the above
        reasons throughout the document</li>
      <li>The <a href="/prolog/faq/">comp.lang.prolog FAQ</a> are described with a DCG.</li>
    </ul>
    </div>

    <center><h2>現在の進展</h2></center>

    DCG（文法規則）は現在、Prolog ISO規格への導入が検討されています。

    <br><br>

    詳細については、Ulrich Neumerkelによる
    <a href="http://www.complang.tuwien.ac.at/ulrich/iso-prolog/"><b>ISO Prolog Works</b></a>
    をご覧ください。

    <br><br>

    DCGの記法は、Haskellのような関数型プログラミング言語で
    最も汎用的な形式の一つとして採用されている<i>モナド</i>に似ています。
    他のプログラミング言語もこのような構文から恩恵を受ける可能性があります。

    <br><br>
    <button onclick="toggleOriginalContent('原文_current_developments')">原文</button>
    <div id="原文_current_developments" class="hide_on_start">
    <center><h2>Current developments</h2></center>

    DCGs are currently being considered for inclusion in the Prolog
    ISO&nbsp;standard.

    <br><br>

    See
    <a href="http://www.complang.tuwien.ac.at/ulrich/iso-prolog/"><b>ISO
        Prolog works</b></a> by Ulrich Neumerkel for more information.

    <br><br>

    DCG notation is similar to <i>monads</i> which have been adopted as
    one of the most versatile among several competing formalisms in
    functional programming languages like&nbsp;Haskell. Other
    programming languages may also benefit from such constructs.
    </div>
    <br><br><br>
    <b><a href="/prolog">More about Prolog</a></b>

    <br><br><br>
    <b><a href="/">Main page</a></b>
    <script src="jquery.js"></script>
    <script src="toc.js"></script>
  </body>
</html>
