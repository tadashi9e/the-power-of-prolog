<html>
  <head>
    <meta charset="UTF-8">
    <title>A Couple of Meta-interpreters in Prolog</title>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Prolog,Meta-interpreter,Interpreter,MI">
    <meta name="author" content="Markus Triska">
    <link rel="stylesheet" type="text/css" href="/prolog/prolog.css">
    <link rel="stylesheet" type="text/css" href="/prolog/toc.css">
    <script>
      document.addEventListener("DOMContentLoaded", function() {
          var all_hide_on_start = document.getElementsByClassName('hide_on_start');
          for (var i = 0, m = all_hide_on_start.length; i < m; i++) {
              var element = all_hide_on_start[i];
              element.style.display = "none";
          }
      });
      function toggleOriginalContent(id) {
          var element = document.getElementById(id);
          if (element.style.display === "none") {
              element.style.display = "block";
          } else {
              element.style.display = "none";
          }
      }
    </script>
  </head>
  <body style="padding-left: 5%; padding-right: 5%; padding-bottom: 3cm">

    <center>
      <h1>Prologにおけるいくつかのメタインタプリタ</h1>
    </center>
    <br><br>
    <button onclick="toggleOriginalContent('原文')">原文</button>
    <div id="原文" class="hide_on_start">
    <center>
      <h1>A Couple of Meta-interpreters in Prolog</h1>
    </center>
    </div>

    <center>
      <h2>動機</h2>
    </center>

    インフォーマルに言えば、インタプリタはプログラムを評価するプログラムです。
    解釈はコンピュータサイエンスにおいて理論的にも実践的にも広く行われており、
    多くのプログラムがドメイン固有の言語のインタプリタです。
    たとえば、設定ファイルから設定を読み取り、
    それに応じて調整するプログラムは、この「設定言語」を解釈しています。

    <br><br>

    自分自身の実装言語に似た、または同一の言語のインタプリタは、
    <i>メタインタプリタ</i>（<i>meta-interpreter</i>、MI）と呼ばれます。
    自分自身を解釈できるインタプリタは、
    <i>メタサーキュラー</i>（<i>meta-circular</i>）と呼ばれます。
    PrologはMIの記述に非常に適しています。
    第一に、Prologプログラムは自然にPrologの
    <a href="/prolog/data#term">項</a>として表現でき、
    <a href="/prolog/concepts#builtins">組み込み</a>の
    メカニズムを使って簡単に検査および操作できます。
    第二に、Prologの暗黙的な計算戦略と全解決述語をインタプリタで利用することで、
    簡潔な仕様が可能になります。
    第三に、オブジェクトレベル（解釈されるプログラム）の変数を
    メタレベル（インタプリタ）での変数として扱うことができるため、
    インタプリタは解釈されるプログラムのバインディング環境の処理を
    基盤となるPrologエンジンに委任することができます。

    <br><br>
    <table>
      <tr>
        <td><i>ビデオ</i>:</td>
        <td><a href="/prolog/videos/meta_interpreters"><img src="/prolog/videos/t_meta_interpreters.png" alt="Prologメタインタプリタ"></a></td>
      </tr>
    </table>

    <br><br>

    以下の簡単なPrologプログラムは、
    この文書全体を通じての実行例として使用されます。
    ここでは標準のProlog構文で示し、その後、さまざまな異なる表現を検討します：

    <pre>
natnum(0).
natnum(s(X)) :-
        natnum(X).
    </pre>

    PrologはPrologコードを動的に評価できます：

    <pre>
?- Goal = natnum(X), Goal.
   Goal = natnum(0), X = 0
;  Goal = natnum(s(0)), X = s(0)
;  ... .
    </pre>

    <b><a href="/prolog/metapredicates#call">call/1</a></b>述語を使って
    呼び出しを明示的にすることができ、
    同等のクエリ「?- Goal = natnum(X), call(Goal).」が得られます。
    <b>call/n</b>（n > 1）系列の述語を使うことで、
    呼び出す前に<i>Goal</i>に追加の引数を付加できます。

    <br><br>

    このメカニズム（「<i>メタコール</i>」 "<i>meta-call</i>"）は、
    <b><a href="/prolog/metapredicates#maplist">maplist/3</a></b>、
    <b>include/3</b>、
    <b>if/3</b>などの述語で使用されており、
    最も粗い意味での解釈と見なすことができます。
    基盤となるエンジンの機能を暗黙的に使用することは<i>吸収</i>と呼ばれ、
    機能を明示的にすることは<i>具現化</i>と呼ばれます。
    <b>call/1</b>を使うことで、
    バックトラッキング、統一、結合の処理、コールスタックなどを
    吸収することができます。
    これらの機能をすべて明示化し、後で調整および拡張することが可能です。

    <br><br>
    <button onclick="toggleOriginalContent('原文_motivation')">原文</button>
    <div id="原文_motivation" class="hide_on_start">
    <center>
      <h2>Motivation</h2>
    </center>

    Informally, an interpreter is a program that evaluates programs.
    Interpretation is pervasive in computer science both from a
    theoretical and practical perspective, and many programs are
    interpreters for domain-specific languages.  For example, a
    program reading settings from a configuration file and adjusting
    itself accordingly is interpreting this "configuration language".

    <br><br>

    An interpreter for a language similar or identical to its own
    implementation language is
    called <i>meta-interpreter</i>&nbsp;(MI). An interpreter that can
    interpret itself is called <i>meta-circular</i>. Prolog is
    exceptionally well-suited for writing&nbsp;MIs: First and most
    importantly, Prolog programs can be naturally represented as
    Prolog&nbsp;<a href="/prolog/data#term">terms</a>
    and are easily inspected and manipulated
    using <a href="/prolog/concepts#builtins">built-in</a>
    mechanisms. Second, Prolog's implicit computation strategy and
    all-solutions predicates can be used in interpreters, allowing for
    concise specifications. Third, variables from the object-level
    (the program to be interpreted) can be treated as variables on the
    meta-level (the interpreter); therefore, an interpreter can
    delegate handling of the interpreted program's binding environment
    to the underlying Prolog engine.

    <br><br>

    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="/prolog/videos/meta_interpreters"><img src="/prolog/videos/t_meta_interpreters.png" alt="Prolog Meta-interpreters"></a>
        </td>
      </tr>
    </table>

    <br><br>

    The following simple Prolog program will serve as a running
    example throughout this text. I state it here using default Prolog
    syntax, and we will subsequently consider various different
    representations for it:

    <pre>
natnum(0).
natnum(s(X)) :-
        natnum(X).
    </pre>

    Prolog can evaluate Prolog code dynamically:

    <pre>
?- Goal = natnum(X), Goal.
   Goal = natnum(0), X = 0
;  Goal = natnum(s(0)), X = s(0)
;  ... .
    </pre>

    You can make the call explicit using the built-in <b><a href="/prolog/metapredicates#call">call/1</a></b>
    predicate, yielding the equivalent query "?- Goal = natnum(X),
    call(Goal).". The <b>call/n</b> (n&nbsp;&gt;&nbsp;1) family of
    predicates lets you append additional arguments to <i>Goal</i>
    before it is called.

    <br><br>

    This mechanism ("<i>meta-call</i>") is used in predicates
    like <b><a href="/prolog/metapredicates#maplist">maplist/3</a></b>, <b>include/3</b>, <b>if/3</b> etc., and can
    be seen as interpretation in its coarsest sense. Implicitly using
    features of the underlying engine is called <i>absorption</i>.
    Making features explicit is called <i>reification</i>. By
    using&nbsp;<b>call/1</b>, we absorb backtracking, unification,
    handling of conjunctions, the call stack etc. We can make all
    these features explicit and subsequently adjust and extend them at
    will.
    </div>

    <center>
      <h2>標準MI</h2>
    </center>

    <br><br>
    <button onclick="toggleOriginalContent('原文_vanilla_mis')">原文</button>
    <div id="原文_vanilla_mis" class="hide_on_start">
    <center><h2>Vanilla MIs</h2> </center>
    </div>

    <center><h3>Prologコードへのアクセス</h3></center>

    <b>natnum/1</b>の定義は2つの節から成り立ちます。
    最初の節は<i>事実</i>として退化しており、
    次のように記述されたかのように暗黙的に扱われます。

    <pre>
natnum(0) :- true.
    </pre>

    Prolog組み込みの<b>clause/2</b>を使うと、述語の定義を確認できます。

    <pre>
?- clause(natnum(Z), Body).
   Z = 0, Body = true
;  Z = s(_A), Body = natnum(_A).
    </pre>

    <b>注意</b>: 節の検査を行うには、
    述語を <i>public</i> にする必要があります。
    述語を <i>public</i> にするための移植性の高い方法として、
    <tt>dynamic/1</tt>ディレクティブを使うことができます。
    動的述語は自動的に公開されるためです。

    <br><br>

    バックトラッキングで見つかった2つの解は、述語の定義の2つの節に対応しています。

    <br><br>

    別の例です。

    <pre>
complicated_clause(A) :-
        goal1(A),
        goal2(A),
        goal3(A).

?- clause(complicated_clause(Z), Body).
Body = (goal1(Z), goal2(Z), goal3(Z)).
    </pre>

    <b>complicated_clause/1</b>の本体は、
    ファンクタ「,」とアリティ2を持つ複合項として表され、
    その引数はゴールか、同じ構造の複合項です。
    以下は、デフォルトの表現における節本体のProlog「型」定義です。

    <pre>
body(true).
body((A,B)) :-
        body(A),
        body(B).
body(G) :-          % 曖昧で、「true」や「(_,_)」にもマッチする
        goal(G).

goal(_ = _).
goal(call(_)).
% ... etc.
    </pre>
    <br>

    これにより、純粋なPrologプログラム用のインタープリタを定義できます。

    <pre>
mi1(true).
mi1((A,B)) :-
        mi1(A),
        mi1(B).
mi1(Goal) :-
        Goal \= true,
        Goal \= (_,_),
        clause(Goal, Body),
        mi1(Body).
    </pre>

    これは<i>標準MI</i>と呼ばれ、特別な機能はありません。
    純粋なPrologに新たな機能を追加しないすべてのMIは、
    標準MIと呼ばれ、拡張のためのスケルトンとして役立ちます。

    <br><br>

    このMIを使って、サンプルプログラムを実行できます。

    <pre>
?- mi1(natnum(X)).
   X = 0
;  X = s(0)
;  X = s(s(0))
;  ... .
    </pre>
    </div>

    <br><br>
    <button onclick="toggleOriginalContent('原文_accessing_prolot_code')">原文</button>
    <div id="原文_accessing_prolot_code" class="hide_on_start">
    <center><h3>Accessing Prolog code</h3></center>

    The definition of <b>natnum/1</b> consists of two clauses, the
    first of which degenerated into a <i>fact</i> that is implicitly
    treated as if it were stated as

    <pre>
natnum(0) :- true.
    </pre>

    The Prolog built-in <b>clause/2</b> allows inspection of the
    predicate's definition:

    <pre>
?- clause(natnum(Z), Body).
   Z = 0, Body = true
;  Z = s(_A), Body = natnum(_A).
    </pre>

    <b>Note</b>: Clause inspection requires the predicate to
    be <i>public</i>. A portable way to declare predicates public is
    to use the <tt>dynamic/1</tt> directive, because dynamic
    predicates are automatically public.

    <br><br>

    The two solutions found on backtracking correspond to the two
    clauses of the predicate's definition.

    <br><br>

    Another example:
    <pre>
complicated_clause(A) :-
        goal1(A),
        goal2(A),
        goal3(A).

?- clause(complicated_clause(Z), Body).
Body = (goal1(Z), goal2(Z), goal3(Z)).
    </pre>

    The body of <b>complicated_clause/1</b> is represented by a
    compound term with functor&nbsp;',' and arity&nbsp;2, whose
    arguments are either goals or compound terms of the same
    structure. Here is a Prolog "type" definition of a clause body in
    the default representation:

    <pre>
body(true).
body((A,B)) :-
        body(A),
        body(B).
body(G) :-          % ambiguous, also matches "true" and "(_,_)"
        goal(G).

goal(_ = _).
goal(call(_)).
% ... etc.
    </pre>
    <br>

    We can thus define an interpreter for pure Prolog programs:

    <pre>
mi1(true).
mi1((A,B)) :-
        mi1(A),
        mi1(B).
mi1(Goal) :-
        Goal \= true,
        Goal \= (_,_),
        clause(Goal, Body),
        mi1(Body).
    </pre>

    This is often called <i>vanilla MI</i> because there's nothing
    special to it. All MIs that add no ability to pure Prolog are
    sometimes called vanilla MIs. They serve as skeletons for
    extensions.

    <br><br>

    We can use this MI to run our example program:


    <pre>
?- mi1(natnum(X)).
   X = 0
;  X = s(0)
;  X = s(s(0))
;  ... .
    </pre>
    </div>

    <center><h3>クリーンな表現の使用</h3></center>

    上記のMIでは、<b>true/0</b>や連言と一致しないように
    3つ目の節をガードする必要がありました。
    これにより、<b>clause/2</b>で
    これらの引数を使うことによるランタイムエラーを防ぎましたが、
    見栄えが悪くなっています。
    さらに、最初の2つの節にカット(<b>!/0</b>)を使用することで
    さらに見栄えが悪くなりますが、
    少なくとも不要な選択ポイントは取り除けます。
    しかし、通常それでは選択ポイントの作成を防げません。
    ゴールが何であるかを示すのではなく、デフォルトケースを導入し、
    何でないかを指定する必要がありました。
    これらの表現は<i>"デフォルティ"</i>
    （<i>"<a href="/prolog/data#clean">defaulty</a>"</i>）と呼ばれます。
    これを修正するため、ゴールに（任意の）ファンクタ<i>g</i>を装備します。

    <br><br>

    <pre>
body(true).
body((A,B)) :-
        body(A),
        body(B).
body(g(G)) :-
        goal(G).
    </pre>

    このような表現は<i>クリーン</i>と呼ばれます。

    <br><br>

    この仕様に従ってサンプルを再構成します。

    <pre>
natnum_clean(0).
natnum_clean(s(X)) :-
        g(natnum_clean(X)).
    </pre>

    <tt>?- natnum_clean(X).</tt>のようなクエリは
    実行時エラーになります（<b>g/1</b>述語が存在しないため）。
    しかし、MIを使用してプログラムを解釈できます。

    <pre>
mi2(true).
mi2((A,B)) :-
        mi2(A),
        mi2(B).
mi2(g(G)) :-
        clause(G, Body),
        mi2(Body).
    </pre>

    このバージョンは短く、<i>クリーン</i>であるだけでなく、
    通常、効率が高くなります
    （第一引数のインデックス付けによる選択ポイントがなく、
    テストが少ないため推論が少なくなります）。

    <pre>
?- integer_natnum(10^6, T), time(mi1(natnum(T))).
   % CPU time: 1.950s, 16_000_015 inferences
   T = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(...)))))))))))))))))))))
;  ... .


?- integer_natnum(10^6, T), time(mi2(g(natnum_clean(T)))).
   % CPU time: 1.442s, 11_000_010 inferences
   T = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(...)))))))))))))))))))))
;  ... .
    </pre>

    <br><br>

    以下において、<b>mi_clause/2</b>は、
    <b>clause/2</b>に似た述語を表しますが、
    条件部（クローズの本体）を「適切な」（MI依存の）形式で提供します。
    このMIに対して：

    <pre>
mi_clause(G, Body) :-
        clause(G, B),
        defaulty_better(B, Body).

defaulty_better(true, true).
defaulty_better((A,B), (BA,BB)) :-
        defaulty_better(A, BA),
        defaulty_better(B, BB).
defaulty_better(G, g(G)) :-
        G \= true,
        G \= (_,_).
    </pre>

    この述語は、第2のMIを使用して、
    通常のPrologコードの一部を解釈することができ、
    また静的な変換にも使用できます。
    あるいは、<b>mi_clause/2</b>は
    以下のように事実によって定義することも可能です。
    このMIに対して：

    <pre>
mi_clause(natnum(0), true).
mi_clause(natnum(s(X)), g(natnum(X)).
    </pre>

    <br><br>
    <button onclick="toggleOriginalContent('原文_using_a_clean_representation')">原文</button>
    <div id="原文_using_a_clean_representation" class="hide_on_start">
    <center><h3>Using a clean representation</h3></center>

    In the preceding MI, we had to guard the third clause from matching
    <b>true/0</b> or conjunctions to prevent run-time errors resulting
    from calling <b>clause/2</b> with these arguments. This is ugly,
    and we can make it uglier still by using cuts&nbsp;(<b>!/0</b>) in
    the first two clauses. That would at least remove unnecessary
    choice-points, though typically not prevent their creation.
    Instead of recognising goals by indication of what they are, we
    had to introduce a "default" case and specify what they aren't.
    Such representations are
    called <i>"<a href="/prolog/data#clean">defaulty</a>"</i>. To
    fix this, we equip goals with the (arbitrary)
    functor&nbsp;<i>g</i>:

    <br><br>


    <pre>
body(true).
body((A,B)) :-
        body(A),
        body(B).
body(g(G)) :-
        goal(G).
    </pre>

    Such a representation is called <i>clean</i>.

    <br><br>

    We rewrite our example according to this specification:

    <pre>
natnum_clean(0).
natnum_clean(s(X)) :-
        g(natnum_clean(X)).
    </pre>

    While a query like "<tt>?- natnum_clean(X).</tt>" would yield a runtime
    error (there is no predicate <b>g/1</b>), we can use an&nbsp;MI to
    interpret the program:

    <pre>
mi2(true).
mi2((A,B)) :-
        mi2(A),
        mi2(B).
mi2(g(G)) :-
        clause(G, Body),
        mi2(Body).
    </pre>

    In addition to being shorter and <i>cleaner</i>, this version is
    typically more efficient (no choice-points due to first-argument
    indexing, and fewer inferences due to fewer tests):

    <pre>
?- integer_natnum(10^6, T), time(mi1(natnum(T))).
   % CPU time: 1.950s, 16_000_015 inferences
   T = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(...)))))))))))))))))))))
;  ... .


?- integer_natnum(10^6, T), time(mi2(g(natnum_clean(T)))).
   % CPU time: 1.442s, 11_000_010 inferences
   T = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(...)))))))))))))))))))))
;  ... .
    </pre>
    <br><br>

    In the following, <b>mi_clause/2</b> denotes a predicate that is
    similar to <b>clause/2</b>, except that it supplies us with an
    "appropriate" (MI-dependent) representation of clause bodies.  For
    the MI at hand:

    <pre>
mi_clause(G, Body) :-
        clause(G, B),
        defaulty_better(B, Body).

defaulty_better(true, true).
defaulty_better((A,B), (BA,BB)) :-
        defaulty_better(A, BA),
        defaulty_better(B, BB).
defaulty_better(G, g(G)) :-
        G \= true,
        G \= (_,_).
    </pre>

    This predicate lets us interpret a subset of normal Prolog code
    with the second&nbsp;MI, and it can also be used for static
    conversion. Alternatively, <b>mi_clause/2</b> can be defined by
    facts. For this&nbsp;MI:

    <pre>
mi_clause(natnum(0), true).
mi_clause(natnum(s(X)), g(natnum(X)).
    </pre>
    </div>

      <center><h3>バリエーションと修正</h3></center>

      これまでに示された2つのMIは、結合を<i>具象化</i>します。
      <b>clause/2</b>を通じて、これらは統一とバックトラックを<i>吸収</i>します。
      結合の処理を明示的にしたことで、ゴールのデフォルト実行順序を逆にすることができます。

    <pre>
mi3(true).
mi3((A,B)) :-
        mi3(B),        % first B, then A
        mi3(A).
mi3(g(G)) :-
        mi_clause(G, Body),
        mi3(Body).
    </pre>

    論理的には、これは何も変わりません（結合は交換可能だからです）。
    手続き的には違いがあります。
    <b>mi_clause/2</b>に小さな調整を加えることで
    （事実「defaulty_better(false, false).」を追加し、
    <i>G</i>を原子<b>false/0</b>から保護する）、
    このMIを使ってクエリ「?- declarative_false.」が、
    述語の定義に基づいて成功できないことを証明することができます。

    <pre>
declarative_false :-
        declarative_false,
        false.
    </pre>

    これは標準の実行順序では導出できません。

    <br><br>

    ゴールを実行する前にユーザーに確認を求める（<i>トレース</i>）、
    実行履歴を印刷する、または安全なゴールへのアクセスを制限することができます。
    そのためには、3つ目の節を調整します。

    <pre>
mi2_safe(g(G)) :-
        (   safe_goal(G) ->
            mi_clause(G, Body),
            mi2_safe(Body)
        ;   throw(cannot_execute(G))
        ).
    </pre>

    <br><br>

    結合をリストとして表現することで、
    よりシンプルなMIを得ることができます。
    この表現では、<b>true/0</b>は空リストになります。

    <pre>
natnum_list(0, []).
natnum_list(s(X), [natnum_list(X)]).
    </pre>

    同様に、実行可能なPrologコードとこの表現の間の変換は自動的に行うことができます。

    <pre>
mi_clause(G, Ls) :-
        clause(G, Body),
        phrase(body_list(Body), Ls).


body_list(true)  --> [].
body_list((A,B)) -->
        body_list(A),
        body_list(B).
body_list(G) -->
        { G \= true },
        { G \= (_,_) },
        [G].
    </pre>

    この表現に対する明白なMIは、次の2つの節のみから成り立ちます。

    <pre>
mi_list1([]).
mi_list1([G|Gs]) :-
        mi_clause(G, Body),
        mi_list1(Body),
        mi_list1(Gs).
    </pre>

    これを末尾再帰化することができます。

    <pre>
mi_list2([]).
mi_list2([G0|Gs0]) :-
        mi_clause(G0, Body),
        append(Body, Gs0, Gs),
        mi_list2(Gs).
    </pre>

    その違いは以下の通りです。

    <pre>
always_infinite :-
        always_infinite.

?- mi_list1([always_infinite]).
<b>エラー: ローカルスタックが不足しました</b>

?- mi_list2([always_infinite]).  % ループするが、スタックスペースは一定
    </pre>

    節の表現にリスト差分を使用することで、
    まだ証明されていないゴールの連結を、ゴールの展開と融合させることができます。

    <pre>
mi_ldclause(natnum(0), Rest, Rest).
mi_ldclause(natnum(s(X)), [natnum(X)|Rest], Rest).

<div id="mi_list3">
mi_list3([]).
mi_list3([G0|Gs0]) :-
        mi_ldclause(G0, Remaining, Gs0),
        mi_list3(Remaining).
</div>
    </pre>

    クエリの例：

    <pre>
?- mi_list3([natnum(X)]).
   X = 0
;  X = s(0)
;  X = s(s(0))
;  ... .
    </pre>
    </div>

    <br><br>
    <button onclick="toggleOriginalContent('原文_variants_and_modifications')">原文</button>
    <div id="原文_variants_and_modifications" class="hide_on_start">
    <center><h3>Variants and modifications</h3></center>

    The 2 MIs presented so far <i>reify</i>
    conjunction. Through <b>clause/2</b>, they <i>absorb</i>
    unification and backtracking.  Having made handling of
    conjunctions explicit, we can reverse the default execution order
    of goals:

    <pre>
mi3(true).
mi3((A,B)) :-
        mi3(B),        % first B, then A
        mi3(A).
mi3(g(G)) :-
        mi_clause(G, Body),
        mi3(Body).
    </pre>

    From a logical point of view, this changes nothing (conjunction is
    commutative). Procedurally, there's a difference: With minor
    adjustments to <b>mi_clause/2</b> (adding the fact
    "defaulty_better(false, false)." and guarding <i>G</i> against the
    atom <b>false/0</b>), this MI can be used to prove that the query
    "?-&nbsp;declarative_false."  cannot succeed given the predicate's
    definition:

    <pre>
declarative_false :-
        declarative_false,
        false.
    </pre>

    This can't be derived with the standard execution order.

    <br><br>

    We can ask the user before we execute goals (<i>tracing</i>),
    print out the execution history or restrict access to safe goals
    by adjusting the third clause:

    <pre>
mi2_safe(g(G)) :-
        (   safe_goal(G) ->
            mi_clause(G, Body),
            mi2_safe(Body)
        ;   throw(cannot_execute(G))
        ).
    </pre>

    <br><br>

    We can obtain a simpler MI by using lists of goals to represent
    conjunctions. In this representation, <b>true/0</b> becomes the
    empty list:

    <pre>
natnum_list(0, []).
natnum_list(s(X), [natnum_list(X)]).
    </pre>

    Again, the conversion between runnable Prolog code and this
    representation can be performed automatically:

    <pre>
mi_clause(G, Ls) :-
        clause(G, Body),
        phrase(body_list(Body), Ls).


body_list(true)  --> [].
body_list((A,B)) -->
        body_list(A),
        body_list(B).
body_list(G) -->
        { G \= true },
        { G \= (_,_) },
        [G].
    </pre>

    An obvious MI for this representation consists of only 2 clauses:

    <pre>
mi_list1([]).
mi_list1([G|Gs]) :-
        mi_clause(G, Body),
        mi_list1(Body),
        mi_list1(Gs).
    </pre>

    We can make it tail-recursive:

    <pre>
mi_list2([]).
mi_list2([G0|Gs0]) :-
        mi_clause(G0, Body),
        append(Body, Gs0, Gs),
        mi_list2(Gs).
    </pre>

    The difference:

    <pre>
always_infinite :-
        always_infinite.

?- mi_list1([always_infinite]).
<b>ERROR: Out of local stack</b>

?- mi_list2([always_infinite]).  % loops, constant stack space
    </pre>

    Using list differences in our clause representation, appending the
    yet-to-be-proved goals can be fused with expanding a goal:

    <pre>
mi_ldclause(natnum(0), Rest, Rest).
mi_ldclause(natnum(s(X)), [natnum(X)|Rest], Rest).

<div id="mi_list3">
mi_list3([]).
mi_list3([G0|Gs0]) :-
        mi_ldclause(G0, Remaining, Gs0),
        mi_list3(Remaining).
</div>
    </pre>

    Example query:

    <pre>
?- mi_list3([natnum(X)]).
   X = 0
;  X = s(0)
;  X = s(s(0))
;  ... .
    </pre>
    </div>

    <center><h3>メタ循環的MI</h3></center>

    ここに、組み込みの述語<b>clause/2</b>と<b>(=)/2</b>を
    扱うことができるMIがあります。

    <pre>
mi_circ(true).
mi_circ((A,B)) :-
        mi_circ(A),
        mi_circ(B).
mi_circ(clause(A,B)) :-
        clause(A,B).
mi_circ(A \= B) :-
        A \= B.
mi_circ(G) :-
        G \= true,
        G \= (_,_),
        G \= (_\=_),
        G \= clause(_,_),
        clause(G, Body),
        mi_circ(Body).
    </pre>

    このMIは自身のソースコードを解釈することができるので、<i>メタ循環的</i>インタプリタです。

    <pre>
?- mi_circ(mi_circ(natnum(X))).
   X = 0
;  X = s(0)
;  X = s(s(0))
;  ... .
    </pre>
    </div>

    <br><br>
    <button onclick="toggleOriginalContent('原文_meta_circular_mi')">原文</button>
    <div id="原文_meta_circular_mi" class="hide_on_start">
    <center><h3>A meta-circular MI</h3></center>

    Here is an MI that can handle the built-in
    predicates <b>clause/2</b> and <b>(\=)/2</b>:

    <pre>
mi_circ(true).
mi_circ((A,B)) :-
        mi_circ(A),
        mi_circ(B).
mi_circ(clause(A,B)) :-
        clause(A,B).
mi_circ(A \= B) :-
        A \= B.
mi_circ(G) :-
        G \= true,
        G \= (_,_),
        G \= (_\=_),
        G \= clause(_,_),
        clause(G, Body),
        mi_circ(Body).
    </pre>

    It can interpret its own source code and is thus
    a <i>meta-circular</i> interpreter:

    <pre>
?- mi_circ(mi_circ(natnum(X))).
   X = 0
;  X = s(0)
;  X = s(s(0))
;  ... .
    </pre>
    </div>

    <center><h3 id="reasoning">プログラムについての推論</h3></center>

    述語<tt>provable/2</tt>を次のように定義しましょう。
    <b>provable(Goal, Defs)</b>は、
    <i>Goal</i>が<i>Defs</i>
    （<i>Defs</i>は<i>Head-Body</i>形式の項として表された節のリスト）
    に関して<i>証明可能</i>であるときに真です。
    これまでに示した他のMI（メタインタプリタ）と比較して、
    主な違いは、節が述語の引数として<i>明示的に</i>渡される点です。

    <br><br>

    さらに、<b>predicate_property/2</b>を使用して
    組み込み述語を直接呼び出すために、それを特定するように一般化しています。

    <pre>
provable(true, _).
provable((A,B), Defs) :-
        provable(A, Defs),
        provable(B, Defs).
provable(g(Goal), Defs) :-
        (   predicate_property(Goal, built_in) ->
            call(Goal)
        ;   member(Def, Defs),
            copy_term(Def, Goal-Body),
            provable(Body, Defs)
        ).
    </pre>

    ここで、変数を新しいコピーに置き換えるために
    <tt>copy_term/2</tt>を使用する必要があることに注意してください。
    また、組み込み述語<b>!/0</b>のこのMIによる解釈は
    意図された意味とは一致せず、カットを正しく扱うMIを作成するには
    さらなる作業が必要です。

    <br><br>

    次の追加定義により、このMIを使用して、
    一部の述語定義における<i>冗長な事実</i>を特定することができます。

    <pre>
redundant(Functor/Arity, Reds) :-
        functor(Term, Functor, Arity),
        findall(Term-Body, mi_clause(Term, Body), Defs),
        setof(Red, Defs^redundant_(Defs, Red), Reds).

redundant_(Defs, Fact) :-
        select(Fact-true, Defs, Rest),
        once(provable(g(Fact), Rest)).
    </pre>

    次の定義があるとします。

    <pre>
as([]).
as([a]).   % redundant
as([a,a]). % redundant
as([A|As]) :-
        A = a,           % test built-in (=)/2
        true,            % test built-in true/0
        as(As).
    </pre>

    この場合、残りのすべての節から導き出せるため、冗長な事実を尋ねることができます。

    <pre>
?- redundant(as/1, Rs).
Rs = [as([a]), as([a, a])].
    </pre>

    したがって、MIを使用して
    場合によってはプログラムの非自明な特性を決定することができます。

    <br><br>

    重要なことは、MIを使用することで、各言語構成要素を
    通常のPrologとは<i>異なる</i>方法で解釈する自由が得られるということです。
    たとえば、<i>抽象解釈</i>を使用して、述語の型やモード情報を導き出すことができます。

    <br><br>

    CodishおよびSøndergaard 2002年の
    「Meta-Circular Abstract Interpretation in Prolog」
    から取られた例が<a href="acomip.pl">ソースファイル</a>にあります。
    固定点計算により、抽象的なパリティ領域における
    アッカーマン関数に関する非自明な事実を導き出します。

    <pre>
?- ack_fixpoint(As).

As = [ack(odd, odd, odd), ack(odd, even, odd), ack(odd, one, odd), ack(even, odd, odd),
      ack(odd, zero, odd), ack(even, even, odd), ack(even, one, odd), ack(one, odd, odd),
      ack(even, zero, odd), ack(one, even, even), ack(one, one, odd), ack(one, zero, even),
      ack(zero, even, odd), ack(zero, odd, even), ack(zero, zero, one), ack(zero, one, even)].
    </pre>

    次のクエリを考えてみましょう。

    <pre>
?- dif(X, one), dif(X, zero), dif(Z, odd), ack_fixpoint(As), member(ack(X,Y,Z), As).
<b>false</b>.
    </pre>

    これにより、<tt>Ackermann(i, j)</tt>が
    すべてのi > 1に対して<i>奇数で1より大きい</i>ことが示されます。

    <br><br>
    <button onclick="toggleOriginalContent('原文_reasoning_about_programs')">原文</button>
    <div id="原文_reasoning_about_programs" class="hide_on_start">
    <center><h3 id="reasoning">Reasoning about programs</h3></center>

    Let us define a predicate <tt>provable/2</tt> as
    follows: <b>provable(Goal, Defs)</b> is true if <i>Goal</i> is
    <i>provable</i> with respect to the definitions <i>Defs</i>, which
    is a list of clauses represented as terms of the
    form&nbsp;<i>Head-Body</i>. In comparison to the other MIs shown
    so far, the main difference is thus that the clauses are made
    available <i>explicitly</i> as an&nbsp;argument of the&nbsp;predicate.

    <br><br>

    In addition, we generalize the handling of built-in predicates by
    using <b>predicate_property/2</b> to identify them as such for
    calling them directly:

    <pre>
provable(true, _).
provable((A,B), Defs) :-
        provable(A, Defs),
        provable(B, Defs).
provable(g(Goal), Defs) :-
        (   predicate_property(Goal, built_in) ->
            call(Goal)
        ;   member(Def, Defs),
            copy_term(Def, Goal-Body),
            provable(Body, Defs)
        ).
    </pre>

    Note that we need to use <tt>copy_term/2</tt> to replace variables
    by fresh&nbsp;copies. Also, how the built-in
    predicate&nbsp;<b>!/0</b> is interpreted by this MI does not match
    its intended meaning, and building an MI that handles cuts
    correctly requires more work.

    <br><br>

    With the following additional definitions, we can use this MI to
    identify <i>redundant&nbsp;facts</i> in some predicate
    definitions:

    <pre>
redundant(Functor/Arity, Reds) :-
        functor(Term, Functor, Arity),
        findall(Term-Body, mi_clause(Term, Body), Defs),
        setof(Red, Defs^redundant_(Defs, Red), Reds).

redundant_(Defs, Fact) :-
        select(Fact-true, Defs, Rest),
        once(provable(g(Fact), Rest)).
    </pre>

    Given the definitions

    <pre>
as([]).
as([a]).   % redundant
as([a,a]). % redundant
as([A|As]) :-
        A = a,           % test built-in (=)/2
        true,            % test built-in true/0
        as(As).
    </pre>

    we can ask for facts which are deducible from all (respective)
    remaining clauses and hence redundant:

    <pre>
?- redundant(as/1, Rs).
Rs = [as([a]), as([a, a])].
    </pre>

    Thus, MIs allow us to determine non-trivial properties of programs
    in some cases.

    <br><br>

    Importantly, MIs give us the freedom to interpret each language
    construct <i>differently</i> than regular Prolog would do&nbsp;it.
    For example, using <i>abstract interpretation</i>, we can derive type
    and mode information of predicates.

    <br><br>

    An example taken from Codish and
    S&oslash;ndergaard&nbsp;2002, <i>Meta-Circular Abstract
    Interpretation in Prolog</i> is in the <a href="acomip.pl">source
    file</a>. By fixpoint computation, we derive non-trivial facts
    about the Ackermann function over an abstract parity domain:

    <pre>
?- ack_fixpoint(As).

As = [ack(odd, odd, odd), ack(odd, even, odd), ack(odd, one, odd), ack(even, odd, odd),
      ack(odd, zero, odd), ack(even, even, odd), ack(even, one, odd), ack(one, odd, odd),
      ack(even, zero, odd), ack(one, even, even), ack(one, one, odd), ack(one, zero, even),
      ack(zero, even, odd), ack(zero, odd, even), ack(zero, zero, one), ack(zero, one, even)].
    </pre>

    Now consider the following query:

    <pre>
?- dif(X, one), dif(X, zero), dif(Z, odd), ack_fixpoint(As), member(ack(X,Y,Z), As).
<b>false</b>.
    </pre>

    This shows that <tt>Ackermann(i, j)</tt> is <i>odd and greater
    than&nbsp;1</i> for all i&nbsp;&gt;&nbsp;1.
    </div>
    
    <center><h3>バックトラックの具象化</h3></center>

    ここでは、<i>バックトラック</i>を具象化してみましょう。
    通常バックトラックで見つかるすべての代替の節の本体を明示し、
    <b>findall/3</b>を使用してそれらを決定的に収集する必要があります。
    1つの代替手段はゴールのリストとして表現され、
    未探索の計算分岐は代替手段のリストとして表現されます。
    インターフェース述語<b>mi_backtrack/1</b>はゴールを引数として取り、
    計算の初期状態の表現を作成します。
    リストは1つの代替手段<tt>[G0]</tt>からなります。
    実際には、表現は<tt>[G0]-G0</tt>であり、
    <tt>G0</tt>はすぐに明らかになる理由により
    ワーカ述語の2番目の引数としても渡されます。

    <pre>
mi_backtrack(G0) :- mi_backtrack_([[G0]-G0], G0).
    </pre>

    算の1ステップを実行するには、まず最初の代替手段の
    最初のゴールと統一する節の本体をすべて収集します。
    見つかったすべての節の本体には、その最初の代替手段の
    残りのゴールが追加され、新しい代替手段が得られます。
    これらの新しい代替手段は他の代替手段の前に追加され、
    計算の新しい状態が得られます。
    リストの差分を使用した節の表現と、
    既存の代替手段を追加するための<b>findall/4</b>を使用すると、
    次のようになります。

    <pre>
resstep_([A|As0], As) :-
        findall(Gs-G, (A = [G0|Rest]-G,mi_ldclause(G0,Gs,Rest)), As, As0).
    </pre>

    <br><br>

    計算のリーフ（すなわち、終了した代替手段）は、
    それ以上証明すべきゴールがないため、
    自動的に代替手段のリストから消えます。
    このため、<tt>A = [G0|Rest]-G</tt>という統一が失敗し、他の代替手段だけが残ります。

    <br><br>

    ワーカ述語は次のとおりです。

    <pre>
mi_backtrack_([[]-G|_], G).
mi_backtrack_(Alts0, G) :-
        resstep_(Alts0, Alts1),
        mi_backtrack_(Alts1, G).
    </pre>

    もし代替手段に対して証明すべきゴールが残っていない場合、
    初期クエリに対する解が見つかり、ユーザーにバインディングが報告されます。
    これが、ユーザーのクエリを持ち運ぶ必要がある理由です。
    2番目の節は、計算がどのように進行するかを説明しています。
    代替手段のリストが上記のように変換され、プロセスが続行されます。

    <br><br>

    すべての代替手段を明示的に表現することで、
    代替手段の順序を変更して推論プロセスを誘導したり、
    （新しい代替手段を<i>追加</i>することで）
    公平な実行戦略を実装したりすることができます。
    また、このMIは、組み込みのバックトラックを持たない言語で
    Prologを実装するために必要なものを示しています。

    <br><br>
    <button onclick="toggleOriginalContent('原文_reifying_backtracking')">原文</button>
    <div id="原文_reifying_backtracking" class="hide_on_start">
    <center><h3>Reifying backtracking</h3></center>

    Let us reify <i>backtracking</i> now. We need to make explicit all
    alternative clause bodies that are normally found on backtracking,
    collecting them deterministically using <b>findall/3</b>. A single
    alternative is represented as a list of goals, and the branches of
    computation that have yet to be explored as a list of
    alternatives. The interface predicate, <b>mi_backtrack/1</b>,
    takes a goal as its argument and creates the representation of the
    initial state of computation: A list, consisting of a single
    alternative, <tt>[G0]</tt>. Actually, the representation is
    <tt>[G0]-G0</tt>, and <tt>G0</tt> is also passed as the second
    argument to the worker predicate for reasons that will become
    clear shortly.


    <pre>
mi_backtrack(G0) :- mi_backtrack_([[G0]-G0], G0).
    </pre>

    To perform a single step of the computation, we first collect all
    clause bodies whose heads unify with the first goal of the first
    alternative. To all found clause bodies, the remaining goals of
    that first alternative are appended, thus obtaining new
    alternatives that we prepend to the other alternatives to give the
    new state of computation. Using the clause representation that
    makes use of list differences, and <b>findall/4</b> to append
    existing alternatives, this becomes:

    <pre>
resstep_([A|As0], As) :-
        findall(Gs-G, (A = [G0|Rest]-G,mi_ldclause(G0,Gs,Rest)), As, As0).
    </pre>

    <br>

    <br><br>

    Leaves of the computation, i.e., alternatives that we are done
    with, automatically vanish from the list of alternatives as there
    is no goal to be proved for them any more. The unification <tt>A =
    [G0|Rest]-G</tt> thus fails and only the other alternatives
    remain.

    <br><br>

    The worker predicate:

    <pre>
mi_backtrack_([[]-G|_], G).
mi_backtrack_(Alts0, G) :-
        resstep_(Alts0, Alts1),
        mi_backtrack_(Alts1, G).
    </pre>

    If no goals remain to be proved for an alternative, a solution for
    the initial query is found and we report the bindings to the user.
    This is why we needed to pass around the user's query. The second
    clause describes how the computation is carried on: The list of
    alternatives is transformed as described above, and the process
    continues.

    <br><br>

    Representing all alternatives explicitly allows us to guide the
    inference process by reordering alternatives, implement fair
    execution strategies (by <i>appending</i> new alternatives) and so
    on. Also, the MI shows what is needed to implement Prolog
    in languages that lack built-in backtracking.
    </div>

    <center>
      <h2>Prolog の拡張</h2>
    </center>

    <br><br>
    <button onclick="toggleOriginalContent('原文_extending_prolog')">原文</button>
    <div id="原文_extending_prolog" class="hide_on_start">
    <center>
      <h2>Extending Prolog</h2>
    </center>
    </div>

    <center><h3>証明の表示</h3></center>

    標準のPrologが提供しない機能が必要な場合、
    それを基本的なメタインタープリタ（MI）に追加できます。
    ここでは、標準の純粋なPrologのように動作し、
    並行して<i>証明木</i>を構築するMIを示します。
    この証明木は、証明に至る推論を明示的に示します。

    <pre>
:- op(750, xfy, =>).

mi_tree(true, true).
mi_tree((A,B), (TA,TB)) :-
        mi_tree(A, TA),
        mi_tree(B, TB).
mi_tree(g(G), TBody => G) :-
        mi_clause(G, Body),
        mi_tree(Body, TBody).
    </pre>

    例のクエリ：<br>

    <pre>
?- mi_tree(g(natnum(X)), T).
   T = true=>natnum(0), X = 0
;  T = (true=>natnum(0))=>natnum(s(0)), X = s(0)
;  T = ((true=>natnum(0))=>natnum(s(0)))=>natnum(s(s(0))), X = s(s(0))
;  ... .
    </pre>

    <br><br>
    <button onclick="toggleOriginalContent('原文_showing_proofs')">原文</button>
    <div id="原文_showing_proofs" class="hide_on_start">
    <center><h3>Showing proofs</h3></center>

    If you want a feature that plain Prolog does not provide, you can
    add it to a vanilla MI. Here is an MI that behaves like standard
    pure Prolog and builds a <i>proof-tree</i> in parallel that makes
    explicit the inferences that lead to the proof:

    <pre>
:- op(750, xfy, =>).

mi_tree(true, true).
mi_tree((A,B), (TA,TB)) :-
        mi_tree(A, TA),
        mi_tree(B, TB).
mi_tree(g(G), TBody => G) :-
        mi_clause(G, Body),
        mi_tree(Body, TBody).
    </pre>

    Example query:<br>

    <pre>
?- mi_tree(g(natnum(X)), T).
   T = true=>natnum(0), X = 0
;  T = (true=>natnum(0))=>natnum(s(0)), X = s(0)
;  T = ((true=>natnum(0))=>natnum(s(0)))=>natnum(s(s(0))), X = s(s(0))
;  ... .
    </pre>
    </div>

    <center><h3>探索戦略の変更</h3></center>

    もう一つの拡張のグループは、不完全なデフォルトの計算戦略を
    改善することを目的としています。
    まず、探索木の深さを制限するMI（メタインタープリタ）から始めます。
    このMIは<a href="/prolog/clpfd">整数演算</a>を使用します：

    <pre>
mi_limit(Goal, Max) :-
        mi_limit(Goal, Max, _).

mi_limit(true, N, N).
mi_limit((A,B), N0, N) :-
        mi_limit(A, N0, N1),
        mi_limit(B, N1, N).
mi_limit(g(G), N0, N) :-
        N0 #> 0,
        N1 #= N0 - 1,
        mi_clause(G, Body),
        mi_limit(Body, N1, N).
    </pre>

    クエリの例：

    <pre>
?- mi_limit(g(natnum(X)), 3).
   X = 0
;  X = s(0)
;  X = s(s(0))
;  false.
    </pre>

    予想通り、<b>natnum/1</b>の場合、
    解の数は探索木の最大深さと一致します。
    このMIを基にして、<i>完全な</i>探索戦略である<i>反復深化探索</i>を実装できます：

    <pre>
mi_id(Goal) :-
        length(_, N),
        mi_limit(Goal, N).
    </pre>

    以下のプログラムを考えてみます：

    <pre>
edge(a, b).
edge(b, a).
edge(b, c).

path(A, A, []).
path(A, C, [e(A,B)|Es]) :-
        edge(A, B),
        path(B, C, Es).
    </pre>

    そして次のクエリ：

    <pre>
?- path(a, c, Es).
<b>ERROR: Out of local stack</b>


?- mi_id(g(path(a, c, Es))).
   <b>Es = [e(a,b),e(b,c)]</b>
;  ... .
    </pre>

    深さ優先探索とは対照的に、反復深化探索は解を見つけます。
    一見すると、反復深化は探索木の多くのノードを繰り返し探索するため、
    非効率的な探索技法のように見えます。
    しかし、一般的な仮定の下では、反復深化は実際には
    <i>最適な</i>探索戦略であることが示されています。
    一般的な探索木では、各レベルのノード数が木の深さとともに指数関数的に増加し、
    最終的な深さですべてのノードを探索するのにかかる時間は、
    以前の探索に費やした時間を<i>定数</i>倍の時間で補えるのです。

    <br><br>
    <button onclick="toggleOriginalContent('原文_changing_search_strategy')">原文</button>
    <div id="原文_changing_search_strategy" class="hide_on_start">
    <center><h3>Changing the search strategy</h3></center>

    Another group of extensions aims to improve the incomplete default
    computation strategy. We start with an MI that limits the depth of
    the search&nbsp;tree,
    using <a href="/prolog/clpfd">integer&nbsp;arithmetic</a>:

    <pre>
mi_limit(Goal, Max) :-
        mi_limit(Goal, Max, _).

mi_limit(true, N, N).
mi_limit((A,B), N0, N) :-
        mi_limit(A, N0, N1),
        mi_limit(B, N1, N).
mi_limit(g(G), N0, N) :-
        N0 #> 0,
        N1 #= N0 - 1,
        mi_clause(G, Body),
        mi_limit(Body, N1, N).
    </pre>

    Example query:

    <pre>
?- mi_limit(g(natnum(X)), 3).
   X = 0
;  X = s(0)
;  X = s(s(0))
;  false.
    </pre>

    As expected, the number of solutions coincides with the maximal
    depth of the search tree in the case of <b>natnum/1</b>.  Based
    on this MI, we can implement a <i>complete</i> search
    strategy, <i>iterative deepening</i>:

    <pre>
mi_id(Goal) :-
        length(_, N),
        mi_limit(Goal, N).
    </pre>

    Consider the program:

    <pre>
edge(a, b).
edge(b, a).
edge(b, c).

path(A, A, []).
path(A, C, [e(A,B)|Es]) :-
        edge(A, B),
        path(B, C, Es).
    </pre>

    And the queries:

    <pre>
?- path(a, c, Es).
<b>ERROR: Out of local stack</b>


?- mi_id(g(path(a, c, Es))).
   <b>Es = [e(a,b),e(b,c)]</b>
;  ... .
    </pre>

    In contrast to depth-first search, iterative deepening finds a
    solution. At first glance, iterative deepening may seem a wasteful
    search technique because many nodes of the search tree are
    explored repeatedly. However, one can show that iterative
    deepening is in fact an <i>optimal</i> search strategy under very
    general assumptions. In a general search tree, the number of nodes
    at each level grows exponentially with the depth of the tree, and
    the time it takes to explore all nodes at the final depth is
    enough to cover the previously expended effort with
    a <i>constant</i> factor.
    </div>

    <center><h3>健全な単一化</h3></center>

    一般的なProlog実装のデフォルトの単一化アルゴリズムでは、
    <i>出現チェック</i>を省略しているため、健全でない推論が生じることがあります。

    <pre>
occ(X, f(X)).
    </pre>

    出現チェックがない場合、次のクエリは成功します。


    <pre>
?- occ(A, A).
    </pre>

    メタインタプリタ(MI)内で、述語のヘッドの単一化に出現チェックを使用することができます。

    <pre>
mi_occ(true).
mi_occ((A,B)) :-
        mi_occ(A),
        mi_occ(B).
mi_occ(g(G)) :-
        functor(G, F, Arity),
        functor(H, F, Arity),
        mi_clause(H, Body),
        unify_with_occurs_check(G, H),
        mi_occ(Body).
    </pre>

    変更の結果、次のクエリは失敗します。

    <pre>
?- mi_occ(g(occ(A,A))).
   false.
    </pre>

    このMIと類似のものを使って、変数の<i>束縛環境</i>を明示化することができます。
    束縛をスレッド化し、第三の節に<tt>unify(G,H)</tt>という形式の項を
    束縛の集合に追加します。
    もし単一化を明示化したい場合、
    <b>numbervars/3</b>を使って変数を取り除くことができます。

    <br><br>
    <button onclick="toggleOriginalContent('原文_sound_unification')">原文</button>
    <div id="原文_sound_unification" class="hide_on_start">
    <center><h3>Sound unification</h3></center>

    Omission of the <i>occurs check</i> in the default unification
    algorithms of common Prolog implementations can lead to unsound
    inference:

    <pre>
occ(X, f(X)).
    </pre>

    Without occurs check, the query

    <pre>
?- occ(A, A).
    </pre>

    succeeds. We can use occurs check for unification of clause heads
    in an MI:

    <pre>
mi_occ(true).
mi_occ((A,B)) :-
        mi_occ(A),
        mi_occ(B).
mi_occ(g(G)) :-
        functor(G, F, Arity),
        functor(H, F, Arity),
        mi_clause(H, Body),
        unify_with_occurs_check(G, H),
        mi_occ(Body).
    </pre>

    We get:

    <pre>
?- mi_occ(g(occ(A,A))).
   false.
    </pre>

    You can use an MI similar to this one to reify the <i>binding
    environment</i> of variables: Thread the bindings through and add
    a term of the form <tt>unify(G,H)</tt> to the set of bindings in the
    third clause. Use <b>numbervars/3</b> to get rid of variables if
    you want to reify unification.
    </div>

    <center><h3>左再帰文法による構文解析</h3></center>

    Prologの計算戦略の結果として、左再帰文法を使用した構文解析は問題が発生します。
    ここでは、左再帰を処理できるように
    確定節文法（<a href="/prolog/dcg"><b>DCG</b></a>）
    を解釈するMI（メタインタープリタ）を定義します。
    次のような簡単な文法を考えます。

    <pre>
dcgnumber(0).
dcgnumber(1).

expr(N)   --> [N], { dcgnumber(N) }.
expr(A+B) --> expr(A), [(+)], expr(B).
    </pre>

    この文法は、記述されている文字列を不公平に列挙するために使用できます。

    <pre>
?- phrase(expr(E), Ss).
   E = 0, Ss = [0]
;  E = 1, Ss = [1]
;  E = 0+0, Ss = [0,+,0]
;  ... .
    </pre>

    しかし、完全に具体化された文字列を解析すると問題が発生します。

    <pre>
?- phrase(expr(E), [1,+,1]).
   E = 1+1
;  <b>ERROR: Out of local stack</b>
    </pre>

    まず、文法をより適切な表現に変換します。

    <pre>
dcg_clause(expr(N),   [t(N),{dcgnumber(N)}]).
dcg_clause(expr(A+B), [l,nt(expr(A)),t(+),nt(expr(B))]).
    </pre>

    第2節の本文にあるアトム<tt>l</tt>は、この節が適用されるためには、
    文字列に少なくとも1つの（したがって、<i>1つ</i>の<tt>l</tt>）
    トークンが残っている必要があることを示します。
    これをMIで使用して、トークンがなくなった場合に検索ツリーを剪定します。
    他の項は、<tt>t/1</tt>がターミナル、<tt>nt/1</tt>が非ターミナル、
    <tt>{}/1</tt>がゴールを表します。

    <br><br>

    MIへのインターフェースは次のようになります。

    <pre>
mi_dcg(NT, String) :-
        length(String, L),
        length(Rest0, L),
        mi_dcg_([nt(NT)], Rest0, _, String, []).
    </pre>

    ワーカー述語は次の通りです。

    <pre>
mi_dcg(t(T), Rest, Rest, [T|Ts], Ts).
mi_dcg({Goal}, Rest, Rest, Ts, Ts) :-
        call(Goal).
mi_dcg(nt(NT), Rest0, Rest, Ts0, Ts) :-
        dcg_clause(NT, Body),
        mi_dcg_(Body, Rest0, Rest, Ts0, Ts).
mi_dcg(l, [_|Rest], Rest, Ts, Ts).

mi_dcg_([], Rest, Rest, Ts, Ts).
mi_dcg_([G|Gs], Rest0, Rest, Ts0, Ts) :-
        mi_dcg(G, Rest0, Rest1, Ts0, Ts1),
        mi_dcg_(Gs, Rest1, Rest, Ts1, Ts).
    </pre>

    これで、左再帰文法を使用して解析を行うことができます。

    <pre>
?- mi_dcg(expr(E), [1,+,1,+,1]).
   E = 1+(1+1)
;  E = 1+1+1
;  false.
    </pre>

    <br><br>
    <button onclick="toggleOriginalContent('原文_parsing_with_left_recursive_grammers')">原文</button>
    <div id="原文_parsing_with_left_recursive_grammers" class="hide_on_start">
    <center><h3>Parsing with left-recursive grammars</h3></center>

    As a consequence of Prolog's computation strategy, parsing with
    left-recursive grammars is problematic. Let us now define an MI
    that interprets <a href="/prolog/dcg"><b>Definite&nbsp;Clause
    Grammars</b></a> in such a way that they can handle
    left-recursion. Consider a simple grammar:

    <pre>
dcgnumber(0).
dcgnumber(1).

expr(N)   --> [N], { dcgnumber(N) }.
expr(A+B) --> expr(A), [(+)], expr(B).
    </pre>

    This grammar can be used to (unfairly) enumerate an arbitrary
    number of strings it describes:

    <pre>
?- phrase(expr(E), Ss).
   E = 0, Ss = [0]
;  E = 1, Ss = [1]
;  E = 0+0, Ss = [0,+,0]
;  ... .
    </pre>

    However, parsing ground strings leads to problems:

    <pre>
?- phrase(expr(E), [1,+,1]).
   E = 1+1
;  <b>ERROR: Out of local stack</b>
    </pre>

    We first convert the grammar into a more suitable representation:

    <pre>
dcg_clause(expr(N),   [t(N),{dcgnumber(N)}]).
dcg_clause(expr(A+B), [l,nt(expr(A)),t(+),nt(expr(B))]).
    </pre>

    The atom <tt>l</tt> in the body of the second clause is used to
    capture that for this clause to apply, there must be at least one
    (therefore, <i>one</i>&nbsp;<tt>l</tt>) token left in the string
    to be parsed. This is used in the MI to prune the search tree if
    we run out of tokens. The other terms are: <tt>t/1</tt> for
    terminals, <tt>nt/1</tt> for non-terminals and <tt>{}/1</tt> for
    goals.

    <br><br>

    The interface to the MI:

    <pre>
mi_dcg(NT, String) :-
        length(String, L),
        length(Rest0, L),
        mi_dcg_([nt(NT)], Rest0, _, String, []).
    </pre>

    The worker predicates:

    <pre>
mi_dcg(t(T), Rest, Rest, [T|Ts], Ts).
mi_dcg({Goal}, Rest, Rest, Ts, Ts) :-
        call(Goal).
mi_dcg(nt(NT), Rest0, Rest, Ts0, Ts) :-
        dcg_clause(NT, Body),
        mi_dcg_(Body, Rest0, Rest, Ts0, Ts).
mi_dcg(l, [_|Rest], Rest, Ts, Ts).

mi_dcg_([], Rest, Rest, Ts, Ts).
mi_dcg_([G|Gs], Rest0, Rest, Ts0, Ts) :-
        mi_dcg(G, Rest0, Rest1, Ts0, Ts1),
        mi_dcg_(Gs, Rest1, Rest, Ts1, Ts).
    </pre>

    We can now use the left-recursive grammar also for parsing:

    <pre>
?- mi_dcg(expr(E), [1,+,1,+,1]).
   E = 1+(1+1)
;  E = 1+1+1
;  false.
    </pre>
    </div>

    <center><h3>さらなる拡張</h3></center>

    モジュールシステム、遅延ゴール、さまざまな種類の無限ループのチェック、
    プロファイリング、デバッグ、型システム、制約解決など、
    他の可能な拡張があります。
    これらの機能をメタインタープリタ（MI）を使って実装する際に発生する
    オーバーヘッドは、部分評価の技術を用いて取り除くことができます。
    たとえば、以下のように部分評価されたDCG（定義句文法）のバージョンを
    （機械的に）導き出すことができます。

    <pre id="pe">
pe_expr(Expr, String) :-
        length(String, L),
        length(Rest0, L),
        pe_expr(Expr, Rest0, _, String, []).

pe_expr(N, Rest, Rest, Ts0, Ts) :-
        Ts0 = [N|Ts],
        dcgnumber(N).
pe_expr(A+B, [_|Rest0], Rest, Ts0, Ts) :-
        pe_expr(A, Rest0, Rest1, Ts0, Ts1),
        Ts1 = [+|Ts2],
        pe_expr(B, Rest1, Rest, Ts2, Ts).
    </pre>
    速度比較:
    <pre>
?- sum_of_ones(10^4, Ss), time(mi_dcg(expr(Sum), Ss)).
   % CPU time: 7.010s, 50_245_019 inferences
   ... .

?- sum_of_ones(10^4, Ss), time(pe_expr(Sum, Ss)).
   % CPU time: 0.016s, 70_012 inferences
   ... .
    </pre>

    <br><br>
    <button onclick="toggleOriginalContent('原文_further_extentions')">原文</button>
    <div id="原文_further_extentions" class="hide_on_start">
    <center><h3>Further extensions</h3></center>


    Other possible extensions are module systems, delayed goals,
    checking for various kinds of infinite loops, profiling,
    debugging, type systems, constraint solving etc. The overhead
    incurred by implementing these things using MIs can be compiled
    away using partial evaluation techniques. For instance, we can
    (mechanically) derive the following partially evaluated version of
    the DCG example:


    <pre id="pe">
pe_expr(Expr, String) :-
        length(String, L),
        length(Rest0, L),
        pe_expr(Expr, Rest0, _, String, []).

pe_expr(N, Rest, Rest, Ts0, Ts) :-
        Ts0 = [N|Ts],
        dcgnumber(N).
pe_expr(A+B, [_|Rest0], Rest, Ts0, Ts) :-
        pe_expr(A, Rest0, Rest1, Ts0, Ts1),
        Ts1 = [+|Ts2],
        pe_expr(B, Rest1, Rest, Ts2, Ts).
    </pre>
    Speed comparison:
    <pre>
?- sum_of_ones(10^4, Ss), time(mi_dcg(expr(Sum), Ss)).
   % CPU time: 7.010s, 50_245_019 inferences
   ... .

?- sum_of_ones(10^4, Ss), time(pe_expr(Sum, Ss)).
   % CPU time: 0.016s, 70_012 inferences
   ... .
    </pre>
    </div>

    <br><br><br>

    Source file containing all examples: <a href="acomip.pl"><b>acomip.pl</b></a>

    <br><br><br>

    Written Sept. 14th 2005<br>

    <br><br><br>

    <b><a href="/prolog">More about Prolog</a></b>

    <br><br><br>

    <b><a href="/">Main page</a></b>

  </body>
  <script src="/prolog/jquery.js"></script>
  <script src="/prolog/toc.js"></script>
</html>
